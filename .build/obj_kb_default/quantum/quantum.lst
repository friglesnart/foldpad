   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB107:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** #include "quantum.h"
   2:quantum/quantum.c **** 
   3:quantum/quantum.c **** #ifndef TAPPING_TERM
   4:quantum/quantum.c **** #define TAPPING_TERM 200
   5:quantum/quantum.c **** #endif
   6:quantum/quantum.c **** 
   7:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 7 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
   8:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 8 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
   9:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  10:quantum/quantum.c ****     break;
  11:quantum/quantum.c ****   default:
  12:quantum/quantum.c ****     return;
  13:quantum/quantum.c ****   }
  14:quantum/quantum.c **** 
  15:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 15 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  16:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 16 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  17:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 17 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  18:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 18 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  19:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 19 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  20:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 20 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  21:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 21 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  22:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 22 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  23:quantum/quantum.c **** 
  24:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 24 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  25:quantum/quantum.c **** 
  26:quantum/quantum.c ****   if (code & QK_RCTL)
  27:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 27 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  28:quantum/quantum.c ****   if (code & QK_RSFT)
  29:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 29 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  30:quantum/quantum.c ****   if (code & QK_RALT)
  31:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 31 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
  32:quantum/quantum.c ****   if (code & QK_RGUI)
  33:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 33 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
  34:quantum/quantum.c **** }
 106               		.loc 1 34 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
  33:quantum/quantum.c **** }
 113               		.loc 1 33 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 34 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE107:
 127               		.section	.text.register_code16,"ax",@progbits
 128               	.global	register_code16
 130               	register_code16:
 131               	.LFB108:
  35:quantum/quantum.c **** 
  36:quantum/quantum.c **** void register_code16 (uint16_t code) {
 132               		.loc 1 36 0
 133               		.cfi_startproc
 134               	.LVL12:
 135 0000 CF93      		push r28
 136               	.LCFI4:
 137               		.cfi_def_cfa_offset 3
 138               		.cfi_offset 28, -2
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 141               	/* stack size = 1 */
 142               	.L__stack_usage = 1
 143 0002 C82F      		mov r28,r24
  37:quantum/quantum.c ****   do_code16 (code, register_code);
 144               		.loc 1 37 0
 145 0004 60E0      		ldi r22,lo8(gs(register_code))
 146 0006 70E0      		ldi r23,hi8(gs(register_code))
 147 0008 0E94 0000 		call do_code16
 148               	.LVL13:
  38:quantum/quantum.c ****   register_code (code);
 149               		.loc 1 38 0
 150 000c 8C2F      		mov r24,r28
 151               	/* epilogue start */
  39:quantum/quantum.c **** }
 152               		.loc 1 39 0
 153 000e CF91      		pop r28
  38:quantum/quantum.c ****   register_code (code);
 154               		.loc 1 38 0
 155 0010 0C94 0000 		jmp register_code
 156               	.LVL14:
 157               		.cfi_endproc
 158               	.LFE108:
 160               		.section	.text.unregister_code16,"ax",@progbits
 161               	.global	unregister_code16
 163               	unregister_code16:
 164               	.LFB109:
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 165               		.loc 1 41 0
 166               		.cfi_startproc
 167               	.LVL15:
 168 0000 CF93      		push r28
 169               	.LCFI5:
 170               		.cfi_def_cfa_offset 3
 171               		.cfi_offset 28, -2
 172 0002 DF93      		push r29
 173               	.LCFI6:
 174               		.cfi_def_cfa_offset 4
 175               		.cfi_offset 29, -3
 176               	/* prologue: function */
 177               	/* frame size = 0 */
 178               	/* stack size = 2 */
 179               	.L__stack_usage = 2
 180 0004 EC01      		movw r28,r24
  42:quantum/quantum.c ****   unregister_code (code);
 181               		.loc 1 42 0
 182 0006 0E94 0000 		call unregister_code
 183               	.LVL16:
  43:quantum/quantum.c ****   do_code16 (code, unregister_code);
 184               		.loc 1 43 0
 185 000a 60E0      		ldi r22,lo8(gs(unregister_code))
 186 000c 70E0      		ldi r23,hi8(gs(unregister_code))
 187 000e CE01      		movw r24,r28
 188               	/* epilogue start */
  44:quantum/quantum.c **** }
 189               		.loc 1 44 0
 190 0010 DF91      		pop r29
 191 0012 CF91      		pop r28
 192               	.LVL17:
  43:quantum/quantum.c ****   do_code16 (code, unregister_code);
 193               		.loc 1 43 0
 194 0014 0C94 0000 		jmp do_code16
 195               	.LVL18:
 196               		.cfi_endproc
 197               	.LFE109:
 199               		.section	.text.process_action_kb,"ax",@progbits
 200               		.weak	process_action_kb
 202               	process_action_kb:
 203               	.LFB110:
  45:quantum/quantum.c **** 
  46:quantum/quantum.c **** __attribute__ ((weak))
  47:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 204               		.loc 1 47 0
 205               		.cfi_startproc
 206               	.LVL19:
 207               	/* prologue: function */
 208               	/* frame size = 0 */
 209               	/* stack size = 0 */
 210               	.L__stack_usage = 0
  48:quantum/quantum.c ****   return true;
  49:quantum/quantum.c **** }
 211               		.loc 1 49 0
 212 0000 81E0      		ldi r24,lo8(1)
 213               	.LVL20:
 214 0002 0895      		ret
 215               		.cfi_endproc
 216               	.LFE110:
 218               		.section	.text.process_record_user,"ax",@progbits
 219               		.weak	process_record_user
 221               	process_record_user:
 222               	.LFB112:
  50:quantum/quantum.c **** 
  51:quantum/quantum.c **** __attribute__ ((weak))
  52:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
  53:quantum/quantum.c ****   return process_record_user(keycode, record);
  54:quantum/quantum.c **** }
  55:quantum/quantum.c **** 
  56:quantum/quantum.c **** __attribute__ ((weak))
  57:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 223               		.loc 1 57 0
 224               		.cfi_startproc
 225               	.LVL21:
 226               	/* prologue: function */
 227               	/* frame size = 0 */
 228               	/* stack size = 0 */
 229               	.L__stack_usage = 0
  58:quantum/quantum.c ****   return true;
  59:quantum/quantum.c **** }
 230               		.loc 1 59 0
 231 0000 81E0      		ldi r24,lo8(1)
 232               	.LVL22:
 233 0002 0895      		ret
 234               		.cfi_endproc
 235               	.LFE112:
 237               		.section	.text.process_record_kb,"ax",@progbits
 238               		.weak	process_record_kb
 240               	process_record_kb:
 241               	.LFB111:
  52:quantum/quantum.c ****   return process_record_user(keycode, record);
 242               		.loc 1 52 0
 243               		.cfi_startproc
 244               	.LVL23:
 245               	/* prologue: function */
 246               	/* frame size = 0 */
 247               	/* stack size = 0 */
 248               	.L__stack_usage = 0
  53:quantum/quantum.c **** }
 249               		.loc 1 53 0
 250 0000 0C94 0000 		jmp process_record_user
 251               	.LVL24:
 252               		.cfi_endproc
 253               	.LFE111:
 255               		.section	.text.reset_keyboard,"ax",@progbits
 256               	.global	reset_keyboard
 258               	reset_keyboard:
 259               	.LFB113:
  60:quantum/quantum.c **** 
  61:quantum/quantum.c **** void reset_keyboard(void) {
 260               		.loc 1 61 0
 261               		.cfi_startproc
 262               	/* prologue: function */
 263               	/* frame size = 0 */
 264               	/* stack size = 0 */
 265               	.L__stack_usage = 0
  62:quantum/quantum.c ****   clear_keyboard();
 266               		.loc 1 62 0
 267 0000 0E94 0000 		call clear_keyboard
 268               	.LVL25:
 269               	.LBB4:
 270               	.LBB5:
 271               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 272               		.loc 2 187 0
 273 0004 2FEF      		ldi r18,lo8(799999)
 274 0006 84E3      		ldi r24,hi8(799999)
 275 0008 9CE0      		ldi r25,hlo8(799999)
 276 000a 2150      	1:	subi r18,1
 277 000c 8040      		sbci r24,0
 278 000e 9040      		sbci r25,0
 279 0010 01F4      		brne 1b
 280 0012 00C0      		rjmp .
 281 0014 0000      		nop
 282               	.LVL26:
 283               	.LBE5:
 284               	.LBE4:
  63:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  64:quantum/quantum.c ****   stop_all_notes();
  65:quantum/quantum.c ****   shutdown_user();
  66:quantum/quantum.c **** #endif
  67:quantum/quantum.c ****   wait_ms(250);
  68:quantum/quantum.c **** #ifdef CATERINA_BOOTLOADER
  69:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
  70:quantum/quantum.c **** #endif
  71:quantum/quantum.c ****   bootloader_jump();
 285               		.loc 1 71 0
 286 0016 0C94 0000 		jmp bootloader_jump
 287               	.LVL27:
 288               		.cfi_endproc
 289               	.LFE113:
 291               		.section	.text.process_record_quantum,"ax",@progbits
 292               	.global	process_record_quantum
 294               	process_record_quantum:
 295               	.LFB114:
  72:quantum/quantum.c **** }
  73:quantum/quantum.c **** 
  74:quantum/quantum.c **** // Shift / paren setup
  75:quantum/quantum.c **** 
  76:quantum/quantum.c **** #ifndef LSPO_KEY
  77:quantum/quantum.c ****   #define LSPO_KEY KC_9
  78:quantum/quantum.c **** #endif
  79:quantum/quantum.c **** #ifndef RSPC_KEY
  80:quantum/quantum.c ****   #define RSPC_KEY KC_0
  81:quantum/quantum.c **** #endif
  82:quantum/quantum.c **** 
  83:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
  84:quantum/quantum.c **** static uint16_t scs_timer = 0;
  85:quantum/quantum.c **** 
  86:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 296               		.loc 1 86 0
 297               		.cfi_startproc
 298               	.LVL28:
 299 0000 FF92      		push r15
 300               	.LCFI7:
 301               		.cfi_def_cfa_offset 3
 302               		.cfi_offset 15, -2
 303 0002 0F93      		push r16
 304               	.LCFI8:
 305               		.cfi_def_cfa_offset 4
 306               		.cfi_offset 16, -3
 307 0004 1F93      		push r17
 308               	.LCFI9:
 309               		.cfi_def_cfa_offset 5
 310               		.cfi_offset 17, -4
 311 0006 CF93      		push r28
 312               	.LCFI10:
 313               		.cfi_def_cfa_offset 6
 314               		.cfi_offset 28, -5
 315 0008 DF93      		push r29
 316               	.LCFI11:
 317               		.cfi_def_cfa_offset 7
 318               		.cfi_offset 29, -6
 319               	/* prologue: function */
 320               	/* frame size = 0 */
 321               	/* stack size = 5 */
 322               	.L__stack_usage = 5
 323 000a 8C01      		movw r16,r24
  87:quantum/quantum.c **** 
  88:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
  89:quantum/quantum.c ****   keypos_t key = record->event.key;
 324               		.loc 1 89 0
 325 000c FC01      		movw r30,r24
 326 000e C081      		ld r28,Z
 327 0010 D181      		ldd r29,Z+1
 328               	.LVL29:
  90:quantum/quantum.c ****   uint16_t keycode;
  91:quantum/quantum.c **** 
  92:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
  93:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
  94:quantum/quantum.c ****     if (!disable_action_cache) {
 329               		.loc 1 94 0
 330 0012 8091 0000 		lds r24,disable_action_cache
 331               	.LVL30:
 332 0016 8111      		cpse r24,__zero_reg__
 333 0018 00C0      		rjmp .L30
 334               	.LBB6:
  95:quantum/quantum.c ****       uint8_t layer;
  96:quantum/quantum.c **** 
  97:quantum/quantum.c ****       if (record->event.pressed) {
 335               		.loc 1 97 0
 336 001a 8281      		ldd r24,Z+2
 337 001c 8823      		tst r24
 338 001e 01F0      		breq .L31
 339               	.LVL31:
  98:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 340               		.loc 1 98 0
 341 0020 CE01      		movw r24,r28
 342 0022 0E94 0000 		call layer_switch_get_layer
 343               	.LVL32:
 344 0026 F82E      		mov r15,r24
 345               	.LVL33:
  99:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 346               		.loc 1 99 0
 347 0028 682F      		mov r22,r24
 348 002a CE01      		movw r24,r28
 349 002c 0E94 0000 		call update_source_layers_cache
 350               	.LVL34:
 351 0030 00C0      		rjmp .L32
 352               	.LVL35:
 353               	.L31:
 100:quantum/quantum.c ****       } else {
 101:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 354               		.loc 1 101 0
 355 0032 CE01      		movw r24,r28
 356 0034 0E94 0000 		call read_source_layers_cache
 357               	.LVL36:
 358 0038 F82E      		mov r15,r24
 359               	.LVL37:
 360               	.L32:
 102:quantum/quantum.c ****       }
 103:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 361               		.loc 1 103 0
 362 003a BE01      		movw r22,r28
 363 003c 8F2D      		mov r24,r15
 364 003e 00C0      		rjmp .L124
 365               	.LVL38:
 366               	.L30:
 367               	.LBE6:
 104:quantum/quantum.c ****     } else
 105:quantum/quantum.c ****   #endif
 106:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 368               		.loc 1 106 0
 369 0040 CE01      		movw r24,r28
 370 0042 0E94 0000 		call layer_switch_get_layer
 371               	.LVL39:
 372 0046 BE01      		movw r22,r28
 373               	.L124:
 374 0048 0E94 0000 		call keymap_key_to_keycode
 375               	.LVL40:
 376 004c EC01      		movw r28,r24
 377               	.LVL41:
 107:quantum/quantum.c **** 
 108:quantum/quantum.c ****     // This is how you use actions here
 109:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 110:quantum/quantum.c ****     //   action_t action;
 111:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 112:quantum/quantum.c ****     //   process_action(record, action);
 113:quantum/quantum.c ****     //   return false;
 114:quantum/quantum.c ****     // }
 115:quantum/quantum.c **** 
 116:quantum/quantum.c ****   if (!(
 117:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 378               		.loc 1 117 0
 379 004e B801      		movw r22,r16
 380 0050 0E94 0000 		call process_record_kb
 381               	.LVL42:
 382 0054 8823      		tst r24
 383 0056 01F4      		brne .+2
 384 0058 00C0      		rjmp .L110
 118:quantum/quantum.c ****   #ifdef MIDI_ENABLE
 119:quantum/quantum.c ****     process_midi(keycode, record) &&
 120:quantum/quantum.c ****   #endif
 121:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 122:quantum/quantum.c ****     process_music(keycode, record) &&
 123:quantum/quantum.c ****   #endif
 124:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 125:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 126:quantum/quantum.c ****   #endif
 127:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 128:quantum/quantum.c ****     process_leader(keycode, record) &&
 385               		.loc 1 128 0 discriminator 2
 386 005a B801      		movw r22,r16
 387 005c CE01      		movw r24,r28
 388 005e 0E94 0000 		call process_leader
 389               	.LVL43:
 117:quantum/quantum.c ****   #ifdef MIDI_ENABLE
 390               		.loc 1 117 0 discriminator 2
 391 0062 8823      		tst r24
 392 0064 01F4      		brne .+2
 393 0066 00C0      		rjmp .L110
 129:quantum/quantum.c ****   #endif
 130:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 131:quantum/quantum.c ****     process_chording(keycode, record) &&
 132:quantum/quantum.c ****   #endif
 133:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 134:quantum/quantum.c ****     process_unicode(keycode, record) &&
 135:quantum/quantum.c ****   #endif
 136:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 137:quantum/quantum.c ****     process_ucis(keycode, record) &&
 138:quantum/quantum.c ****   #endif
 139:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 140:quantum/quantum.c ****     process_printer(keycode, record) &&
 141:quantum/quantum.c ****   #endif
 142:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 143:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 144:quantum/quantum.c ****   #endif
 145:quantum/quantum.c ****       true)) {
 146:quantum/quantum.c ****     return false;
 147:quantum/quantum.c ****   }
 148:quantum/quantum.c **** 
 149:quantum/quantum.c ****   // Shift / paren setup
 150:quantum/quantum.c **** 
 151:quantum/quantum.c ****   switch(keycode) {
 394               		.loc 1 151 0
 395 0068 C633      		cpi r28,54
 396 006a F0E7      		ldi r31,112
 397 006c DF07      		cpc r29,r31
 398 006e 01F4      		brne .L130
 152:quantum/quantum.c ****     case RESET:
 153:quantum/quantum.c ****       if (record->event.pressed) {
 154:quantum/quantum.c ****         reset_keyboard();
 155:quantum/quantum.c ****       }
 156:quantum/quantum.c **** 	  return false;
 157:quantum/quantum.c ****       break;
 158:quantum/quantum.c ****     case DEBUG:
 159:quantum/quantum.c ****       if (record->event.pressed) {
 160:quantum/quantum.c ****           print("\nDEBUG: enabled.\n");
 161:quantum/quantum.c ****           debug_enable = true;
 162:quantum/quantum.c ****       }
 163:quantum/quantum.c **** 	  return false;
 164:quantum/quantum.c ****       break;
 165:quantum/quantum.c **** 	#ifdef RGBLIGHT_ENABLE
 166:quantum/quantum.c **** 	case RGB_TOG:
 167:quantum/quantum.c **** 		if (record->event.pressed) {
 168:quantum/quantum.c **** 			rgblight_toggle();
 169:quantum/quantum.c ****       }
 170:quantum/quantum.c **** 	  return false;
 171:quantum/quantum.c ****       break;
 172:quantum/quantum.c **** 	case RGB_MOD:
 173:quantum/quantum.c **** 		if (record->event.pressed) {
 174:quantum/quantum.c **** 			rgblight_step();
 175:quantum/quantum.c ****       }
 176:quantum/quantum.c **** 	  return false;
 177:quantum/quantum.c ****       break;
 178:quantum/quantum.c **** 	case RGB_HUI:
 179:quantum/quantum.c **** 		if (record->event.pressed) {
 399               		.loc 1 179 0
 400 0070 F801      		movw r30,r16
 401 0072 8281      		ldd r24,Z+2
 402 0074 8823      		tst r24
 403 0076 01F4      		brne .+2
 404 0078 00C0      		rjmp .L110
 180:quantum/quantum.c **** 			rgblight_increase_hue();
 405               		.loc 1 180 0
 406 007a 0E94 0000 		call rgblight_increase_hue
 407               	.LVL44:
 408 007e 00C0      		rjmp .L110
 409               	.L130:
 151:quantum/quantum.c ****     case RESET:
 410               		.loc 1 151 0
 411 0080 C733      		cpi r28,55
 412 0082 80E7      		ldi r24,112
 413 0084 D807      		cpc r29,r24
 414 0086 00F0      		brlo .+2
 415 0088 00C0      		rjmp .L83
 416 008a C531      		cpi r28,21
 417 008c 90E7      		ldi r25,112
 418 008e D907      		cpc r29,r25
 419 0090 00F0      		brlo .+2
 420 0092 00C0      		rjmp .L84
 421 0094 C230      		cpi r28,2
 422 0096 E0E7      		ldi r30,112
 423 0098 DE07      		cpc r29,r30
 424 009a 00F4      		brsh .+2
 425 009c 00C0      		rjmp .L131
 181:quantum/quantum.c ****       }
 182:quantum/quantum.c **** 	  return false;
 183:quantum/quantum.c ****       break;
 184:quantum/quantum.c **** 	case RGB_HUD:
 185:quantum/quantum.c **** 		if (record->event.pressed) {
 186:quantum/quantum.c **** 			rgblight_decrease_hue();
 187:quantum/quantum.c ****       }
 188:quantum/quantum.c **** 	  return false;
 189:quantum/quantum.c ****       break;
 190:quantum/quantum.c **** 	case RGB_SAI:
 191:quantum/quantum.c **** 		if (record->event.pressed) {
 192:quantum/quantum.c **** 			rgblight_increase_sat();
 193:quantum/quantum.c ****       }
 194:quantum/quantum.c **** 	  return false;
 195:quantum/quantum.c ****       break;
 196:quantum/quantum.c **** 	case RGB_SAD:
 197:quantum/quantum.c **** 		if (record->event.pressed) {
 198:quantum/quantum.c **** 			rgblight_decrease_sat();
 199:quantum/quantum.c ****       }
 200:quantum/quantum.c **** 	  return false;
 201:quantum/quantum.c ****       break;
 202:quantum/quantum.c **** 	case RGB_VAI:
 203:quantum/quantum.c **** 		if (record->event.pressed) {
 204:quantum/quantum.c **** 			rgblight_increase_val();
 205:quantum/quantum.c ****       }
 206:quantum/quantum.c **** 	  return false;
 207:quantum/quantum.c ****       break;
 208:quantum/quantum.c **** 	case RGB_VAD:
 209:quantum/quantum.c **** 		if (record->event.pressed) {
 210:quantum/quantum.c **** 			rgblight_decrease_val();
 211:quantum/quantum.c ****       }
 212:quantum/quantum.c **** 	  return false;
 213:quantum/quantum.c ****       break;
 214:quantum/quantum.c **** 	#endif
 215:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 216:quantum/quantum.c ****       if (record->event.pressed) {
 426               		.loc 1 216 0
 427 009e F801      		movw r30,r16
 428 00a0 8281      		ldd r24,Z+2
 429 00a2 8823      		tst r24
 430 00a4 01F4      		brne .+2
 431 00a6 00C0      		rjmp .L49
 217:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 218:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 432               		.loc 1 218 0
 433 00a8 0E94 0000 		call eeconfig_is_enabled
 434               	.LVL45:
 435 00ac 8111      		cpse r24,__zero_reg__
 436 00ae 00C0      		rjmp .L50
 219:quantum/quantum.c ****             eeconfig_init();
 437               		.loc 1 219 0
 438 00b0 0E94 0000 		call eeconfig_init
 439               	.LVL46:
 440               	.L50:
 220:quantum/quantum.c ****         }
 221:quantum/quantum.c ****         /* keymap config */
 222:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 441               		.loc 1 222 0
 442 00b4 0E94 0000 		call eeconfig_read_keymap
 443               	.LVL47:
 444 00b8 90E0      		ldi r25,0
 445 00ba 9093 0000 		sts keymap_config+1,r25
 446 00be 8093 0000 		sts keymap_config,r24
 223:quantum/quantum.c ****         switch (keycode)
 447               		.loc 1 223 0
 448 00c2 FE01      		movw r30,r28
 449 00c4 E350      		subi r30,3
 450 00c6 F047      		sbci r31,112
 451 00c8 E231      		cpi r30,18
 452 00ca F105      		cpc r31,__zero_reg__
 453 00cc 00F4      		brsh .L51
 454 00ce E050      		subi r30,lo8(-(gs(.L53)))
 455 00d0 F040      		sbci r31,hi8(-(gs(.L53)))
 224:quantum/quantum.c ****         {
 225:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 226:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 227:quantum/quantum.c ****             break;
 228:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 229:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 230:quantum/quantum.c ****             break;
 231:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 232:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 233:quantum/quantum.c ****             break;
 234:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 235:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 236:quantum/quantum.c ****             break;
 237:quantum/quantum.c ****           case MAGIC_NO_GUI:
 238:quantum/quantum.c ****             keymap_config.no_gui = true;
 239:quantum/quantum.c ****             break;
 240:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 241:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 242:quantum/quantum.c ****             break;
 243:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 244:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 245:quantum/quantum.c ****             break;
 246:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 247:quantum/quantum.c ****             keymap_config.nkro = true;
 248:quantum/quantum.c ****             break;
 249:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 250:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 251:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 252:quantum/quantum.c ****             break;
 253:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 254:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 255:quantum/quantum.c ****             break;
 256:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 257:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 258:quantum/quantum.c ****             break;
 259:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 260:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 261:quantum/quantum.c ****             break;
 262:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 263:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 264:quantum/quantum.c ****             break;
 265:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 266:quantum/quantum.c ****             keymap_config.no_gui = false;
 267:quantum/quantum.c ****             break;
 268:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 269:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 270:quantum/quantum.c ****             break;
 271:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 272:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 273:quantum/quantum.c ****             break;
 274:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 275:quantum/quantum.c ****             keymap_config.nkro = false;
 276:quantum/quantum.c ****             break;
 277:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 278:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 279:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 280:quantum/quantum.c ****             break;
 281:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 282:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 456               		.loc 1 282 0
 457 00d2 8091 0000 		lds r24,keymap_config
 223:quantum/quantum.c ****         switch (keycode)
 458               		.loc 1 223 0
 459 00d6 0C94 0000 		jmp __tablejump2__
 460               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 461               		.p2align	1
 462               	.L53:
 463 0000 0000      		.word gs(.L52)
 464 0002 0000      		.word gs(.L54)
 465 0004 0000      		.word gs(.L129)
 466 0006 0000      		.word gs(.L56)
 467 0008 0000      		.word gs(.L57)
 468 000a 0000      		.word gs(.L58)
 469 000c 0000      		.word gs(.L59)
 470 000e 0000      		.word gs(.L60)
 471 0010 0000      		.word gs(.L61)
 472 0012 0000      		.word gs(.L62)
 473 0014 0000      		.word gs(.L63)
 474 0016 0000      		.word gs(.L128)
 475 0018 0000      		.word gs(.L65)
 476 001a 0000      		.word gs(.L66)
 477 001c 0000      		.word gs(.L67)
 478 001e 0000      		.word gs(.L68)
 479 0020 0000      		.word gs(.L69)
 480 0022 0000      		.word gs(.L70)
 481               		.section	.text.process_record_quantum
 482               	.L51:
 226:quantum/quantum.c ****             break;
 483               		.loc 1 226 0
 484 00da 8091 0000 		lds r24,keymap_config
 485 00de 8160      		ori r24,lo8(1<<0)
 486 00e0 00C0      		rjmp .L125
 487               	.L52:
 229:quantum/quantum.c ****             break;
 488               		.loc 1 229 0
 489 00e2 8260      		ori r24,lo8(1<<1)
 490 00e4 00C0      		rjmp .L125
 491               	.L54:
 232:quantum/quantum.c ****             break;
 492               		.loc 1 232 0
 493 00e6 8460      		ori r24,lo8(1<<2)
 494 00e8 00C0      		rjmp .L125
 495               	.L56:
 238:quantum/quantum.c ****             break;
 496               		.loc 1 238 0
 497 00ea 8061      		ori r24,lo8(1<<4)
 498 00ec 00C0      		rjmp .L125
 499               	.L57:
 241:quantum/quantum.c ****             break;
 500               		.loc 1 241 0
 501 00ee 8062      		ori r24,lo8(1<<5)
 502 00f0 00C0      		rjmp .L125
 503               	.L58:
 244:quantum/quantum.c ****             break;
 504               		.loc 1 244 0
 505 00f2 8064      		ori r24,lo8(1<<6)
 506 00f4 00C0      		rjmp .L125
 507               	.L59:
 247:quantum/quantum.c ****             break;
 508               		.loc 1 247 0
 509 00f6 8068      		ori r24,lo8(1<<7)
 510 00f8 00C0      		rjmp .L125
 511               	.L60:
 251:quantum/quantum.c ****             break;
 512               		.loc 1 251 0
 513 00fa 8460      		ori r24,lo8(4)
 514               	.L129:
 515 00fc 8860      		ori r24,lo8(1<<3)
 516 00fe 00C0      		rjmp .L125
 517               	.L61:
 254:quantum/quantum.c ****             break;
 518               		.loc 1 254 0
 519 0100 8E7F      		andi r24,lo8(~(1<<0))
 520 0102 00C0      		rjmp .L125
 521               	.L62:
 257:quantum/quantum.c ****             break;
 522               		.loc 1 257 0
 523 0104 8D7F      		andi r24,lo8(~(1<<1))
 524 0106 00C0      		rjmp .L125
 525               	.L63:
 260:quantum/quantum.c ****             break;
 526               		.loc 1 260 0
 527 0108 8B7F      		andi r24,lo8(~(1<<2))
 528 010a 00C0      		rjmp .L125
 529               	.L65:
 266:quantum/quantum.c ****             break;
 530               		.loc 1 266 0
 531 010c 8F7E      		andi r24,lo8(~(1<<4))
 532 010e 00C0      		rjmp .L125
 533               	.L66:
 269:quantum/quantum.c ****             break;
 534               		.loc 1 269 0
 535 0110 8F7D      		andi r24,lo8(~(1<<5))
 536 0112 00C0      		rjmp .L125
 537               	.L67:
 272:quantum/quantum.c ****             break;
 538               		.loc 1 272 0
 539 0114 8F7B      		andi r24,lo8(~(1<<6))
 540 0116 00C0      		rjmp .L125
 541               	.L68:
 275:quantum/quantum.c ****             break;
 542               		.loc 1 275 0
 543 0118 8F77      		andi r24,lo8(~(1<<7))
 544 011a 00C0      		rjmp .L125
 545               	.L69:
 279:quantum/quantum.c ****             break;
 546               		.loc 1 279 0
 547 011c 8B7F      		andi r24,lo8(-5)
 548               	.L128:
 549 011e 877F      		andi r24,lo8(~(1<<3))
 550 0120 00C0      		rjmp .L125
 551               	.L70:
 552               		.loc 1 282 0
 553 0122 87FB      		bst r24,7
 554 0124 2227      		clr r18
 555 0126 20F9      		bld r18,0
 556 0128 91E0      		ldi r25,lo8(1)
 557 012a 9227      		eor r25,r18
 558 012c 90FB      		bst r25,0
 559 012e 87F9      		bld r24,7
 560               	.L125:
 561 0130 8093 0000 		sts keymap_config,r24
 283:quantum/quantum.c ****             break;
 284:quantum/quantum.c ****           default:
 285:quantum/quantum.c ****             break;
 286:quantum/quantum.c ****         }
 287:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 562               		.loc 1 287 0
 563 0134 8091 0000 		lds r24,keymap_config
 564 0138 0E94 0000 		call eeconfig_update_keymap
 565               	.LVL48:
 288:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 566               		.loc 1 288 0
 567 013c 0E94 0000 		call clear_keyboard
 568               	.LVL49:
 289:quantum/quantum.c **** 
 290:quantum/quantum.c ****         return false;
 569               		.loc 1 290 0
 570 0140 00C0      		rjmp .L110
 571               	.L131:
 151:quantum/quantum.c ****     case RESET:
 572               		.loc 1 151 0
 573 0142 C115      		cp r28,__zero_reg__
 574 0144 F0E7      		ldi r31,112
 575 0146 DF07      		cpc r29,r31
 576 0148 01F0      		breq .L36
 577 014a C130      		cpi r28,1
 578 014c D047      		sbci r29,112
 579 014e 01F0      		breq .L39
 580               	.L82:
 291:quantum/quantum.c ****       }
 292:quantum/quantum.c ****       break;
 293:quantum/quantum.c ****     case KC_LSPO: {
 294:quantum/quantum.c ****       if (record->event.pressed) {
 295:quantum/quantum.c ****         shift_interrupted[0] = false;
 296:quantum/quantum.c ****         scs_timer = timer_read ();
 297:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 298:quantum/quantum.c ****       }
 299:quantum/quantum.c ****       else {
 300:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 301:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 302:quantum/quantum.c ****             shift_interrupted[0] = true;
 303:quantum/quantum.c ****             shift_interrupted[1] = true;
 304:quantum/quantum.c ****           }
 305:quantum/quantum.c ****         #endif
 306:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer) < TAPPING_TERM) {
 307:quantum/quantum.c ****           register_code(LSPO_KEY);
 308:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 309:quantum/quantum.c ****         }
 310:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 311:quantum/quantum.c ****       }
 312:quantum/quantum.c ****       return false;
 313:quantum/quantum.c ****       // break;
 314:quantum/quantum.c ****     }
 315:quantum/quantum.c **** 
 316:quantum/quantum.c ****     case KC_RSPC: {
 317:quantum/quantum.c ****       if (record->event.pressed) {
 318:quantum/quantum.c ****         shift_interrupted[1] = false;
 319:quantum/quantum.c ****         scs_timer = timer_read ();
 320:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 321:quantum/quantum.c ****       }
 322:quantum/quantum.c ****       else {
 323:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 324:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 325:quantum/quantum.c ****             shift_interrupted[0] = true;
 326:quantum/quantum.c ****             shift_interrupted[1] = true;
 327:quantum/quantum.c ****           }
 328:quantum/quantum.c ****         #endif
 329:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer) < TAPPING_TERM) {
 330:quantum/quantum.c ****           register_code(RSPC_KEY);
 331:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 332:quantum/quantum.c ****         }
 333:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 334:quantum/quantum.c ****       }
 335:quantum/quantum.c ****       return false;
 336:quantum/quantum.c ****       // break;
 337:quantum/quantum.c ****     }
 338:quantum/quantum.c ****     default: {
 339:quantum/quantum.c ****       shift_interrupted[0] = true;
 581               		.loc 1 339 0
 582 0150 81E0      		ldi r24,lo8(1)
 583 0152 8093 0000 		sts shift_interrupted,r24
 340:quantum/quantum.c ****       shift_interrupted[1] = true;
 584               		.loc 1 340 0
 585 0156 8093 0000 		sts shift_interrupted+1,r24
 586               	.L49:
 341:quantum/quantum.c ****       break;
 342:quantum/quantum.c ****     }
 343:quantum/quantum.c ****   }
 344:quantum/quantum.c **** 
 345:quantum/quantum.c ****   return process_action_kb(record);
 587               		.loc 1 345 0
 588 015a C801      		movw r24,r16
 589               	/* epilogue start */
 346:quantum/quantum.c **** }
 590               		.loc 1 346 0
 591 015c DF91      		pop r29
 592 015e CF91      		pop r28
 593               	.LVL50:
 594 0160 1F91      		pop r17
 595 0162 0F91      		pop r16
 596               	.LVL51:
 597 0164 FF90      		pop r15
 345:quantum/quantum.c **** }
 598               		.loc 1 345 0
 599 0166 0C94 0000 		jmp process_action_kb
 600               	.LVL52:
 601               	.L36:
 153:quantum/quantum.c ****         reset_keyboard();
 602               		.loc 1 153 0
 603 016a F801      		movw r30,r16
 604 016c 8281      		ldd r24,Z+2
 605 016e 8823      		tst r24
 606 0170 01F4      		brne .+2
 607 0172 00C0      		rjmp .L110
 154:quantum/quantum.c ****       }
 608               		.loc 1 154 0
 609 0174 0E94 0000 		call reset_keyboard
 610               	.LVL53:
 611 0178 00C0      		rjmp .L110
 612               	.L39:
 159:quantum/quantum.c ****           print("\nDEBUG: enabled.\n");
 613               		.loc 1 159 0
 614 017a F801      		movw r30,r16
 615 017c 8281      		ldd r24,Z+2
 616 017e 8823      		tst r24
 617 0180 01F4      		brne .+2
 618 0182 00C0      		rjmp .L110
 161:quantum/quantum.c ****       }
 619               		.loc 1 161 0
 620 0184 8091 0000 		lds r24,debug_config
 621 0188 8160      		ori r24,lo8(1<<0)
 622 018a 8093 0000 		sts debug_config,r24
 623 018e 00C0      		rjmp .L110
 624               	.L84:
 151:quantum/quantum.c ****     case RESET:
 625               		.loc 1 151 0
 626 0190 C433      		cpi r28,52
 627 0192 90E7      		ldi r25,112
 628 0194 D907      		cpc r29,r25
 629 0196 01F4      		brne .L132
 167:quantum/quantum.c **** 			rgblight_toggle();
 630               		.loc 1 167 0
 631 0198 F801      		movw r30,r16
 632 019a 8281      		ldd r24,Z+2
 633 019c 8823      		tst r24
 634 019e 01F4      		brne .+2
 635 01a0 00C0      		rjmp .L110
 168:quantum/quantum.c ****       }
 636               		.loc 1 168 0
 637 01a2 0E94 0000 		call rgblight_toggle
 638               	.LVL54:
 639 01a6 00C0      		rjmp .L110
 640               	.L132:
 151:quantum/quantum.c ****     case RESET:
 641               		.loc 1 151 0
 642 01a8 C533      		cpi r28,53
 643 01aa D047      		sbci r29,112
 644 01ac 01F4      		brne .L82
 173:quantum/quantum.c **** 			rgblight_step();
 645               		.loc 1 173 0
 646 01ae F801      		movw r30,r16
 647 01b0 8281      		ldd r24,Z+2
 648 01b2 8823      		tst r24
 649 01b4 01F4      		brne .+2
 650 01b6 00C0      		rjmp .L110
 174:quantum/quantum.c ****       }
 651               		.loc 1 174 0
 652 01b8 0E94 0000 		call rgblight_step
 653               	.LVL55:
 654 01bc 00C0      		rjmp .L110
 655               	.L83:
 151:quantum/quantum.c ****     case RESET:
 656               		.loc 1 151 0
 657 01be CA33      		cpi r28,58
 658 01c0 F0E7      		ldi r31,112
 659 01c2 DF07      		cpc r29,r31
 660 01c4 01F4      		brne .L133
 203:quantum/quantum.c **** 			rgblight_increase_val();
 661               		.loc 1 203 0
 662 01c6 F801      		movw r30,r16
 663 01c8 8281      		ldd r24,Z+2
 664 01ca 8823      		tst r24
 665 01cc 01F4      		brne .+2
 666 01ce 00C0      		rjmp .L110
 204:quantum/quantum.c ****       }
 667               		.loc 1 204 0
 668 01d0 0E94 0000 		call rgblight_increase_val
 669               	.LVL56:
 670 01d4 00C0      		rjmp .L110
 671               	.L133:
 151:quantum/quantum.c ****     case RESET:
 672               		.loc 1 151 0
 673 01d6 CB33      		cpi r28,59
 674 01d8 80E7      		ldi r24,112
 675 01da D807      		cpc r29,r24
 676 01dc 00F4      		brsh .L85
 677 01de F801      		movw r30,r16
 678 01e0 8281      		ldd r24,Z+2
 679 01e2 C833      		cpi r28,56
 680 01e4 F0E7      		ldi r31,112
 681 01e6 DF07      		cpc r29,r31
 682 01e8 01F4      		brne .L134
 191:quantum/quantum.c **** 			rgblight_increase_sat();
 683               		.loc 1 191 0
 684 01ea 8823      		tst r24
 685 01ec 01F4      		brne .+2
 686 01ee 00C0      		rjmp .L110
 192:quantum/quantum.c ****       }
 687               		.loc 1 192 0
 688 01f0 0E94 0000 		call rgblight_increase_sat
 689               	.LVL57:
 690 01f4 00C0      		rjmp .L110
 691               	.L134:
 151:quantum/quantum.c ****     case RESET:
 692               		.loc 1 151 0
 693 01f6 C933      		cpi r28,57
 694 01f8 D047      		sbci r29,112
 695 01fa 00F4      		brsh .L135
 185:quantum/quantum.c **** 			rgblight_decrease_hue();
 696               		.loc 1 185 0
 697 01fc 8823      		tst r24
 698 01fe 01F4      		brne .+2
 699 0200 00C0      		rjmp .L110
 186:quantum/quantum.c ****       }
 700               		.loc 1 186 0
 701 0202 0E94 0000 		call rgblight_decrease_hue
 702               	.LVL58:
 703 0206 00C0      		rjmp .L110
 704               	.L135:
 197:quantum/quantum.c **** 			rgblight_decrease_sat();
 705               		.loc 1 197 0
 706 0208 8823      		tst r24
 707 020a 01F4      		brne .+2
 708 020c 00C0      		rjmp .L110
 198:quantum/quantum.c ****       }
 709               		.loc 1 198 0
 710 020e 0E94 0000 		call rgblight_decrease_sat
 711               	.LVL59:
 712 0212 00C0      		rjmp .L110
 713               	.L85:
 151:quantum/quantum.c ****     case RESET:
 714               		.loc 1 151 0
 715 0214 CC33      		cpi r28,60
 716 0216 E0E7      		ldi r30,112
 717 0218 DE07      		cpc r29,r30
 718 021a 01F4      		brne .L136
 294:quantum/quantum.c ****         shift_interrupted[0] = false;
 719               		.loc 1 294 0
 720 021c F801      		movw r30,r16
 721 021e 8281      		ldd r24,Z+2
 722 0220 8823      		tst r24
 723 0222 01F0      		breq .L73
 295:quantum/quantum.c ****         scs_timer = timer_read ();
 724               		.loc 1 295 0
 725 0224 1092 0000 		sts shift_interrupted,__zero_reg__
 296:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 726               		.loc 1 296 0
 727 0228 0E94 0000 		call timer_read
 728               	.LVL60:
 729 022c 9093 0000 		sts scs_timer+1,r25
 730 0230 8093 0000 		sts scs_timer,r24
 297:quantum/quantum.c ****       }
 731               		.loc 1 297 0
 732 0234 82E0      		ldi r24,lo8(2)
 733 0236 00C0      		rjmp .L126
 734               	.L73:
 306:quantum/quantum.c ****           register_code(LSPO_KEY);
 735               		.loc 1 306 0
 736 0238 8091 0000 		lds r24,shift_interrupted
 737 023c 8111      		cpse r24,__zero_reg__
 738 023e 00C0      		rjmp .L75
 306:quantum/quantum.c ****           register_code(LSPO_KEY);
 739               		.loc 1 306 0 is_stmt 0 discriminator 1
 740 0240 8091 0000 		lds r24,scs_timer
 741 0244 9091 0000 		lds r25,scs_timer+1
 742 0248 0E94 0000 		call timer_elapsed
 743               	.LVL61:
 744 024c 883C      		cpi r24,-56
 745 024e 9105      		cpc r25,__zero_reg__
 746 0250 00F4      		brsh .L75
 307:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 747               		.loc 1 307 0 is_stmt 1
 748 0252 86E2      		ldi r24,lo8(38)
 749 0254 0E94 0000 		call register_code
 750               	.LVL62:
 308:quantum/quantum.c ****         }
 751               		.loc 1 308 0
 752 0258 86E2      		ldi r24,lo8(38)
 753 025a 0E94 0000 		call unregister_code
 754               	.LVL63:
 755               	.L75:
 310:quantum/quantum.c ****       }
 756               		.loc 1 310 0
 757 025e 82E0      		ldi r24,lo8(2)
 758 0260 00C0      		rjmp .L127
 759               	.L136:
 151:quantum/quantum.c ****     case RESET:
 760               		.loc 1 151 0
 761 0262 CC33      		cpi r28,60
 762 0264 F0E7      		ldi r31,112
 763 0266 DF07      		cpc r29,r31
 764 0268 00F0      		brlo .L47
 765 026a CD33      		cpi r28,61
 766 026c D047      		sbci r29,112
 767 026e 01F0      		breq .+2
 768 0270 00C0      		rjmp .L82
 317:quantum/quantum.c ****         shift_interrupted[1] = false;
 769               		.loc 1 317 0
 770 0272 F801      		movw r30,r16
 771 0274 8281      		ldd r24,Z+2
 772 0276 8823      		tst r24
 773 0278 01F0      		breq .L78
 318:quantum/quantum.c ****         scs_timer = timer_read ();
 774               		.loc 1 318 0
 775 027a 1092 0000 		sts shift_interrupted+1,__zero_reg__
 319:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 776               		.loc 1 319 0
 777 027e 0E94 0000 		call timer_read
 778               	.LVL64:
 779 0282 9093 0000 		sts scs_timer+1,r25
 780 0286 8093 0000 		sts scs_timer,r24
 320:quantum/quantum.c ****       }
 781               		.loc 1 320 0
 782 028a 80E2      		ldi r24,lo8(32)
 783               	.L126:
 784 028c 0E94 0000 		call register_mods
 785               	.LVL65:
 786 0290 00C0      		rjmp .L110
 787               	.L78:
 329:quantum/quantum.c ****           register_code(RSPC_KEY);
 788               		.loc 1 329 0
 789 0292 8091 0000 		lds r24,shift_interrupted+1
 790 0296 8823      		tst r24
 791 0298 01F0      		breq .L137
 792               	.L80:
 333:quantum/quantum.c ****       }
 793               		.loc 1 333 0
 794 029a 80E2      		ldi r24,lo8(32)
 795               	.L127:
 796 029c 0E94 0000 		call unregister_mods
 797               	.LVL66:
 798 02a0 00C0      		rjmp .L110
 799               	.L47:
 209:quantum/quantum.c **** 			rgblight_decrease_val();
 800               		.loc 1 209 0
 801 02a2 F801      		movw r30,r16
 802 02a4 8281      		ldd r24,Z+2
 803 02a6 8823      		tst r24
 804 02a8 01F0      		breq .L110
 210:quantum/quantum.c ****       }
 805               		.loc 1 210 0
 806 02aa 0E94 0000 		call rgblight_decrease_val
 807               	.LVL67:
 808 02ae 00C0      		rjmp .L110
 809               	.L137:
 329:quantum/quantum.c ****           register_code(RSPC_KEY);
 810               		.loc 1 329 0 discriminator 1
 811 02b0 8091 0000 		lds r24,scs_timer
 812 02b4 9091 0000 		lds r25,scs_timer+1
 813 02b8 0E94 0000 		call timer_elapsed
 814               	.LVL68:
 815 02bc 883C      		cpi r24,-56
 816 02be 9105      		cpc r25,__zero_reg__
 817 02c0 00F4      		brsh .L80
 330:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 818               		.loc 1 330 0
 819 02c2 87E2      		ldi r24,lo8(39)
 820 02c4 0E94 0000 		call register_code
 821               	.LVL69:
 331:quantum/quantum.c ****         }
 822               		.loc 1 331 0
 823 02c8 87E2      		ldi r24,lo8(39)
 824 02ca 0E94 0000 		call unregister_code
 825               	.LVL70:
 826 02ce 00C0      		rjmp .L80
 827               	.L110:
 828               		.loc 1 346 0
 829 02d0 80E0      		ldi r24,0
 830               	/* epilogue start */
 831 02d2 DF91      		pop r29
 832 02d4 CF91      		pop r28
 833               	.LVL71:
 834 02d6 1F91      		pop r17
 835 02d8 0F91      		pop r16
 836               	.LVL72:
 837 02da FF90      		pop r15
 838 02dc 0895      		ret
 839               		.cfi_endproc
 840               	.LFE114:
 842               		.section	.text.send_string,"ax",@progbits
 843               	.global	send_string
 845               	send_string:
 846               	.LFB115:
 347:quantum/quantum.c **** 
 348:quantum/quantum.c **** const bool ascii_to_qwerty_shift_lut[0x80] PROGMEM = {
 349:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 350:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 351:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 352:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 353:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 354:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 355:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 356:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 357:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 358:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 359:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 360:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 361:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 362:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 363:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 364:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 365:quantum/quantum.c **** };
 366:quantum/quantum.c **** 
 367:quantum/quantum.c **** const uint8_t ascii_to_qwerty_keycode_lut[0x80] PROGMEM = {
 368:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 369:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 370:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 371:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 372:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 373:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 374:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 375:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 376:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 377:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 378:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 379:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 380:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 381:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 382:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 383:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 384:quantum/quantum.c **** };
 385:quantum/quantum.c **** 
 386:quantum/quantum.c **** /* for users whose OSes are set to Colemak */
 387:quantum/quantum.c **** #if 0
 388:quantum/quantum.c **** #include "keymap_colemak.h"
 389:quantum/quantum.c **** 
 390:quantum/quantum.c **** const bool ascii_to_colemak_shift_lut[0x80] PROGMEM = {
 391:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 392:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 393:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 394:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 395:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 396:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 397:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 398:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 399:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 400:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 401:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 402:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 403:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 404:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 405:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 406:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 407:quantum/quantum.c **** };
 408:quantum/quantum.c **** 
 409:quantum/quantum.c **** const uint8_t ascii_to_colemak_keycode_lut[0x80] PROGMEM = {
 410:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 411:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 412:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 413:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 414:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 415:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 416:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 417:quantum/quantum.c ****     KC_8, KC_9, CM_SCLN, CM_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 418:quantum/quantum.c ****     KC_2, CM_A, CM_B, CM_C, CM_D, CM_E, CM_F, CM_G,
 419:quantum/quantum.c ****     CM_H, CM_I, CM_J, CM_K, CM_L, CM_M, CM_N, CM_O,
 420:quantum/quantum.c ****     CM_P, CM_Q, CM_R, CM_S, CM_T, CM_U, CM_V, CM_W,
 421:quantum/quantum.c ****     CM_X, CM_Y, CM_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 422:quantum/quantum.c ****     KC_GRV, CM_A, CM_B, CM_C, CM_D, CM_E, CM_F, CM_G,
 423:quantum/quantum.c ****     CM_H, CM_I, CM_J, CM_K, CM_L, CM_M, CM_N, CM_O,
 424:quantum/quantum.c ****     CM_P, CM_Q, CM_R, CM_S, CM_T, CM_U, CM_V, CM_W,
 425:quantum/quantum.c ****     CM_X, CM_Y, CM_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 426:quantum/quantum.c **** };
 427:quantum/quantum.c **** 
 428:quantum/quantum.c **** #endif
 429:quantum/quantum.c **** 
 430:quantum/quantum.c **** void send_string(const char *str) {
 847               		.loc 1 430 0
 848               		.cfi_startproc
 849               	.LVL73:
 850 0000 0F93      		push r16
 851               	.LCFI12:
 852               		.cfi_def_cfa_offset 3
 853               		.cfi_offset 16, -2
 854 0002 1F93      		push r17
 855               	.LCFI13:
 856               		.cfi_def_cfa_offset 4
 857               		.cfi_offset 17, -3
 858 0004 CF93      		push r28
 859               	.LCFI14:
 860               		.cfi_def_cfa_offset 5
 861               		.cfi_offset 28, -4
 862               	/* prologue: function */
 863               	/* frame size = 0 */
 864               	/* stack size = 3 */
 865               	.L__stack_usage = 3
 866 0006 8C01      		movw r16,r24
 867               	.LVL74:
 868               	.L142:
 869               	.LBB7:
 870               	.LBB8:
 431:quantum/quantum.c ****     while (1) {
 432:quantum/quantum.c ****         uint8_t keycode;
 433:quantum/quantum.c ****         uint8_t ascii_code = pgm_read_byte(str);
 871               		.loc 1 433 0
 872 0008 F801      		movw r30,r16
 873               	/* #APP */
 874               	 ;  433 "quantum/quantum.c" 1
 875 000a 2491      		lpm r18, Z
 876               		
 877               	 ;  0 "" 2
 878               	.LVL75:
 879               	/* #NOAPP */
 880               	.LBE8:
 434:quantum/quantum.c ****         if (!ascii_code) break;
 881               		.loc 1 434 0
 882 000c 2223      		tst r18
 883 000e 01F0      		breq .L138
 884               	.LBB9:
 435:quantum/quantum.c ****         keycode = pgm_read_byte(&ascii_to_qwerty_keycode_lut[ascii_code]);
 885               		.loc 1 435 0
 886 0010 30E0      		ldi r19,0
 887               	.LVL76:
 888 0012 F901      		movw r30,r18
 889 0014 E050      		subi r30,lo8(-(ascii_to_qwerty_keycode_lut))
 890 0016 F040      		sbci r31,hi8(-(ascii_to_qwerty_keycode_lut))
 891               	.LVL77:
 892               	/* #APP */
 893               	 ;  435 "quantum/quantum.c" 1
 894 0018 C491      		lpm r28, Z
 895               		
 896               	 ;  0 "" 2
 897               	.LVL78:
 898               	/* #NOAPP */
 899               	.LBE9:
 900               	.LBB10:
 436:quantum/quantum.c ****         if (pgm_read_byte(&ascii_to_qwerty_shift_lut[ascii_code])) {
 901               		.loc 1 436 0
 902 001a F901      		movw r30,r18
 903               	.LVL79:
 904 001c E050      		subi r30,lo8(-(ascii_to_qwerty_shift_lut))
 905 001e F040      		sbci r31,hi8(-(ascii_to_qwerty_shift_lut))
 906               	.LVL80:
 907               	/* #APP */
 908               	 ;  436 "quantum/quantum.c" 1
 909 0020 2491      		lpm r18, Z
 910               		
 911               	 ;  0 "" 2
 912               	.LVL81:
 913               	/* #NOAPP */
 914               	.LBE10:
 915 0022 2223      		tst r18
 916 0024 01F0      		breq .L140
 437:quantum/quantum.c ****             register_code(KC_LSFT);
 917               		.loc 1 437 0
 918 0026 81EE      		ldi r24,lo8(-31)
 919 0028 0E94 0000 		call register_code
 920               	.LVL82:
 438:quantum/quantum.c ****             register_code(keycode);
 921               		.loc 1 438 0
 922 002c 8C2F      		mov r24,r28
 923 002e 0E94 0000 		call register_code
 924               	.LVL83:
 439:quantum/quantum.c ****             unregister_code(keycode);
 925               		.loc 1 439 0
 926 0032 8C2F      		mov r24,r28
 927 0034 0E94 0000 		call unregister_code
 928               	.LVL84:
 440:quantum/quantum.c ****             unregister_code(KC_LSFT);
 929               		.loc 1 440 0
 930 0038 81EE      		ldi r24,lo8(-31)
 931 003a 00C0      		rjmp .L143
 932               	.LVL85:
 933               	.L140:
 441:quantum/quantum.c ****         }
 442:quantum/quantum.c ****         else {
 443:quantum/quantum.c ****             register_code(keycode);
 934               		.loc 1 443 0
 935 003c 8C2F      		mov r24,r28
 936 003e 0E94 0000 		call register_code
 937               	.LVL86:
 444:quantum/quantum.c ****             unregister_code(keycode);
 938               		.loc 1 444 0
 939 0042 8C2F      		mov r24,r28
 940               	.L143:
 941 0044 0E94 0000 		call unregister_code
 942               	.LVL87:
 445:quantum/quantum.c ****         }
 446:quantum/quantum.c ****         ++str;
 943               		.loc 1 446 0
 944 0048 0F5F      		subi r16,-1
 945 004a 1F4F      		sbci r17,-1
 946               	.LVL88:
 947               	.LBE7:
 447:quantum/quantum.c ****     }
 948               		.loc 1 447 0
 949 004c 00C0      		rjmp .L142
 950               	.LVL89:
 951               	.L138:
 952               	/* epilogue start */
 448:quantum/quantum.c **** }
 953               		.loc 1 448 0
 954 004e CF91      		pop r28
 955 0050 1F91      		pop r17
 956 0052 0F91      		pop r16
 957               	.LVL90:
 958 0054 0895      		ret
 959               		.cfi_endproc
 960               	.LFE115:
 962               		.section	.text.update_tri_layer,"ax",@progbits
 963               	.global	update_tri_layer
 965               	update_tri_layer:
 966               	.LFB116:
 449:quantum/quantum.c **** 
 450:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 967               		.loc 1 450 0
 968               		.cfi_startproc
 969               	.LVL91:
 970 0000 CF92      		push r12
 971               	.LCFI15:
 972               		.cfi_def_cfa_offset 3
 973               		.cfi_offset 12, -2
 974 0002 DF92      		push r13
 975               	.LCFI16:
 976               		.cfi_def_cfa_offset 4
 977               		.cfi_offset 13, -3
 978 0004 EF92      		push r14
 979               	.LCFI17:
 980               		.cfi_def_cfa_offset 5
 981               		.cfi_offset 14, -4
 982 0006 FF92      		push r15
 983               	.LCFI18:
 984               		.cfi_def_cfa_offset 6
 985               		.cfi_offset 15, -5
 986 0008 0F93      		push r16
 987               	.LCFI19:
 988               		.cfi_def_cfa_offset 7
 989               		.cfi_offset 16, -6
 990 000a 1F93      		push r17
 991               	.LCFI20:
 992               		.cfi_def_cfa_offset 8
 993               		.cfi_offset 17, -7
 994               	/* prologue: function */
 995               	/* frame size = 0 */
 996               	/* stack size = 6 */
 997               	.L__stack_usage = 6
 998 000c 01E0      		ldi r16,lo8(1)
 999 000e 10E0      		ldi r17,0
 1000 0010 20E0      		ldi r18,0
 1001 0012 30E0      		ldi r19,0
 1002 0014 6801      		movw r12,r16
 1003 0016 7901      		movw r14,r18
 1004 0018 00C0      		rjmp 2f
 1005               		1:
 1006 001a CC0C      		lsl r12
 1007 001c DD1C      		rol r13
 1008 001e EE1C      		rol r14
 1009 0020 FF1C      		rol r15
 1010               		2:
 1011 0022 6A95      		dec r22
 1012 0024 02F4      		brpl 1b
 1013 0026 00C0      		rjmp 2f
 1014               		1:
 1015 0028 000F      		lsl r16
 1016 002a 111F      		rol r17
 1017 002c 221F      		rol r18
 1018 002e 331F      		rol r19
 1019               		2:
 1020 0030 8A95      		dec r24
 1021 0032 02F4      		brpl 1b
 1022 0034 0C29      		or r16,r12
 1023 0036 1D29      		or r17,r13
 1024 0038 2E29      		or r18,r14
 1025 003a 3F29      		or r19,r15
 451:quantum/quantum.c ****   if (IS_LAYER_ON(layer1) && IS_LAYER_ON(layer2)) {
 1026               		.loc 1 451 0
 1027 003c 8091 0000 		lds r24,layer_state
 1028 0040 9091 0000 		lds r25,layer_state+1
 1029 0044 A091 0000 		lds r26,layer_state+2
 1030 0048 B091 0000 		lds r27,layer_state+3
 1031               	.LVL92:
 1032 004c 8023      		and r24,r16
 1033 004e 9123      		and r25,r17
 1034 0050 A223      		and r26,r18
 1035 0052 B323      		and r27,r19
 1036 0054 0817      		cp r16,r24
 1037 0056 1907      		cpc r17,r25
 1038 0058 2A07      		cpc r18,r26
 1039 005a 3B07      		cpc r19,r27
 1040 005c 01F4      		brne .L145
 452:quantum/quantum.c ****     layer_on(layer3);
 1041               		.loc 1 452 0
 1042 005e 842F      		mov r24,r20
 1043               	/* epilogue start */
 453:quantum/quantum.c ****   } else {
 454:quantum/quantum.c ****     layer_off(layer3);
 455:quantum/quantum.c ****   }
 456:quantum/quantum.c **** }
 1044               		.loc 1 456 0
 1045 0060 1F91      		pop r17
 1046 0062 0F91      		pop r16
 1047 0064 FF90      		pop r15
 1048 0066 EF90      		pop r14
 1049 0068 DF90      		pop r13
 1050 006a CF90      		pop r12
 452:quantum/quantum.c ****     layer_on(layer3);
 1051               		.loc 1 452 0
 1052 006c 0C94 0000 		jmp layer_on
 1053               	.LVL93:
 1054               	.L145:
 454:quantum/quantum.c ****   }
 1055               		.loc 1 454 0
 1056 0070 842F      		mov r24,r20
 1057               	/* epilogue start */
 1058               		.loc 1 456 0
 1059 0072 1F91      		pop r17
 1060 0074 0F91      		pop r16
 1061 0076 FF90      		pop r15
 1062 0078 EF90      		pop r14
 1063 007a DF90      		pop r13
 1064 007c CF90      		pop r12
 454:quantum/quantum.c ****   }
 1065               		.loc 1 454 0
 1066 007e 0C94 0000 		jmp layer_off
 1067               	.LVL94:
 1068               		.cfi_endproc
 1069               	.LFE116:
 1071               		.section	.text.tap_random_base64,"ax",@progbits
 1072               	.global	tap_random_base64
 1074               	tap_random_base64:
 1075               	.LFB117:
 457:quantum/quantum.c **** 
 458:quantum/quantum.c **** void tap_random_base64(void) {
 1076               		.loc 1 458 0
 1077               		.cfi_startproc
 1078 0000 CF93      		push r28
 1079               	.LCFI21:
 1080               		.cfi_def_cfa_offset 3
 1081               		.cfi_offset 28, -2
 1082 0002 DF93      		push r29
 1083               	.LCFI22:
 1084               		.cfi_def_cfa_offset 4
 1085               		.cfi_offset 29, -3
 1086               	/* prologue: function */
 1087               	/* frame size = 0 */
 1088               	/* stack size = 2 */
 1089               	.L__stack_usage = 2
 459:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 460:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1090               		.loc 1 460 0
 1091 0004 26B5      		in r18,0x26
 1092 0006 C091 8400 		lds r28,132
 1093 000a D091 8500 		lds r29,132+1
 1094 000e 4091 9400 		lds r20,148
 1095 0012 5091 9500 		lds r21,148+1
 1096 0016 8091 BE00 		lds r24,190
 1097 001a 9091 BF00 		lds r25,190+1
 1098 001e C40F      		add r28,r20
 1099 0020 C20F      		add r28,r18
 1100 0022 8C0F      		add r24,r28
 1101 0024 C82F      		mov r28,r24
 1102 0026 CF73      		andi r28,lo8(63)
 1103               	.LVL95:
 461:quantum/quantum.c ****   #else
 462:quantum/quantum.c ****     uint8_t key = rand() % 64;
 463:quantum/quantum.c ****   #endif
 464:quantum/quantum.c ****   switch (key) {
 1104               		.loc 1 464 0
 1105 0028 CE33      		cpi r28,lo8(62)
 1106 002a 00F4      		brsh .L148
 1107 002c C533      		cpi r28,lo8(53)
 1108 002e 00F4      		brsh .L149
 1109 0030 CA31      		cpi r28,lo8(26)
 1110 0032 00F0      		brlo .L147
 1111 0034 C433      		cpi r28,lo8(52)
 1112 0036 00F4      		brsh .L154
 465:quantum/quantum.c ****     case 0 ... 25:
 466:quantum/quantum.c ****       register_code(KC_LSFT);
 467:quantum/quantum.c ****       register_code(key + KC_A);
 468:quantum/quantum.c ****       unregister_code(key + KC_A);
 469:quantum/quantum.c ****       unregister_code(KC_LSFT);
 470:quantum/quantum.c ****       break;
 471:quantum/quantum.c ****     case 26 ... 51:
 472:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1113               		.loc 1 472 0
 1114 0038 C651      		subi r28,lo8(-(-22))
 1115               	.LVL96:
 1116 003a 00C0      		rjmp .L157
 1117               	.LVL97:
 1118               	.L148:
 464:quantum/quantum.c ****     case 0 ... 25:
 1119               		.loc 1 464 0
 1120 003c CE33      		cpi r28,lo8(62)
 1121 003e 01F0      		breq .L152
 1122 0040 CF33      		cpi r28,lo8(63)
 1123 0042 01F0      		breq .L153
 1124               	.L147:
 466:quantum/quantum.c ****       register_code(key + KC_A);
 1125               		.loc 1 466 0
 1126 0044 81EE      		ldi r24,lo8(-31)
 1127 0046 0E94 0000 		call register_code
 1128               	.LVL98:
 467:quantum/quantum.c ****       unregister_code(key + KC_A);
 1129               		.loc 1 467 0
 1130 004a CC5F      		subi r28,lo8(-(4))
 1131               	.LVL99:
 1132 004c 8C2F      		mov r24,r28
 1133 004e 0E94 0000 		call register_code
 1134               	.LVL100:
 468:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1135               		.loc 1 468 0
 1136 0052 8C2F      		mov r24,r28
 1137 0054 00C0      		rjmp .L156
 1138               	.LVL101:
 1139               	.L154:
 473:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 474:quantum/quantum.c ****       break;
 475:quantum/quantum.c ****     case 52:
 476:quantum/quantum.c ****       register_code(KC_0);
 1140               		.loc 1 476 0
 1141 0056 87E2      		ldi r24,lo8(39)
 1142 0058 0E94 0000 		call register_code
 1143               	.LVL102:
 477:quantum/quantum.c ****       unregister_code(KC_0);
 1144               		.loc 1 477 0
 1145 005c 87E2      		ldi r24,lo8(39)
 1146 005e 00C0      		rjmp .L155
 1147               	.L149:
 478:quantum/quantum.c ****       break;
 479:quantum/quantum.c ****     case 53 ... 61:
 480:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1148               		.loc 1 480 0
 1149 0060 C751      		subi r28,lo8(-(-23))
 1150               	.LVL103:
 1151               	.L157:
 1152 0062 8C2F      		mov r24,r28
 1153               	.LVL104:
 1154 0064 0E94 0000 		call register_code
 1155               	.LVL105:
 481:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1156               		.loc 1 481 0
 1157 0068 8C2F      		mov r24,r28
 1158 006a 00C0      		rjmp .L155
 1159               	.LVL106:
 1160               	.L152:
 482:quantum/quantum.c ****       break;
 483:quantum/quantum.c ****     case 62:
 484:quantum/quantum.c ****       register_code(KC_LSFT);
 1161               		.loc 1 484 0
 1162 006c 81EE      		ldi r24,lo8(-31)
 1163 006e 0E94 0000 		call register_code
 1164               	.LVL107:
 485:quantum/quantum.c ****       register_code(KC_EQL);
 1165               		.loc 1 485 0
 1166 0072 8EE2      		ldi r24,lo8(46)
 1167 0074 0E94 0000 		call register_code
 1168               	.LVL108:
 486:quantum/quantum.c ****       unregister_code(KC_EQL);
 1169               		.loc 1 486 0
 1170 0078 8EE2      		ldi r24,lo8(46)
 1171               	.LVL109:
 1172               	.L156:
 1173 007a 0E94 0000 		call unregister_code
 1174               	.LVL110:
 487:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1175               		.loc 1 487 0
 1176 007e 81EE      		ldi r24,lo8(-31)
 1177 0080 00C0      		rjmp .L155
 1178               	.LVL111:
 1179               	.L153:
 488:quantum/quantum.c ****       break;
 489:quantum/quantum.c ****     case 63:
 490:quantum/quantum.c ****       register_code(KC_SLSH);
 1180               		.loc 1 490 0
 1181 0082 88E3      		ldi r24,lo8(56)
 1182 0084 0E94 0000 		call register_code
 1183               	.LVL112:
 491:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1184               		.loc 1 491 0
 1185 0088 88E3      		ldi r24,lo8(56)
 1186               	.LVL113:
 1187               	.L155:
 1188               	/* epilogue start */
 492:quantum/quantum.c ****       break;
 493:quantum/quantum.c ****   }
 494:quantum/quantum.c **** }
 1189               		.loc 1 494 0
 1190 008a DF91      		pop r29
 1191 008c CF91      		pop r28
 491:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1192               		.loc 1 491 0
 1193 008e 0C94 0000 		jmp unregister_code
 1194               	.LVL114:
 1195               		.cfi_endproc
 1196               	.LFE117:
 1198               		.section	.text.matrix_init_quantum,"ax",@progbits
 1199               	.global	matrix_init_quantum
 1201               	matrix_init_quantum:
 1202               	.LFB118:
 495:quantum/quantum.c **** 
 496:quantum/quantum.c **** void matrix_init_quantum() {
 1203               		.loc 1 496 0
 1204               		.cfi_startproc
 1205               	/* prologue: function */
 1206               	/* frame size = 0 */
 1207               	/* stack size = 0 */
 1208               	.L__stack_usage = 0
 497:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 498:quantum/quantum.c ****     backlight_init_ports();
 499:quantum/quantum.c ****   #endif
 500:quantum/quantum.c ****   matrix_init_kb();
 1209               		.loc 1 500 0
 1210 0000 0C94 0000 		jmp matrix_init_kb
 1211               	.LVL115:
 1212               		.cfi_endproc
 1213               	.LFE118:
 1215               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1216               	.global	matrix_scan_quantum
 1218               	matrix_scan_quantum:
 1219               	.LFB119:
 501:quantum/quantum.c **** }
 502:quantum/quantum.c **** 
 503:quantum/quantum.c **** void matrix_scan_quantum() {
 1220               		.loc 1 503 0
 1221               		.cfi_startproc
 1222               	/* prologue: function */
 1223               	/* frame size = 0 */
 1224               	/* stack size = 0 */
 1225               	.L__stack_usage = 0
 504:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 505:quantum/quantum.c ****     matrix_scan_music();
 506:quantum/quantum.c ****   #endif
 507:quantum/quantum.c **** 
 508:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 509:quantum/quantum.c ****     matrix_scan_tap_dance();
 510:quantum/quantum.c ****   #endif
 511:quantum/quantum.c ****   matrix_scan_kb();
 1226               		.loc 1 511 0
 1227 0000 0C94 0000 		jmp matrix_scan_kb
 1228               	.LVL116:
 1229               		.cfi_endproc
 1230               	.LFE119:
 1232               		.section	.text.backlight_init_ports,"ax",@progbits
 1233               		.weak	backlight_init_ports
 1235               	backlight_init_ports:
 1236               	.LFB138:
 1237               		.cfi_startproc
 1238               	/* prologue: function */
 1239               	/* frame size = 0 */
 1240               	/* stack size = 0 */
 1241               	.L__stack_usage = 0
 1242 0000 0895      		ret
 1243               		.cfi_endproc
 1244               	.LFE138:
 1246               		.section	.text.send_nibble,"ax",@progbits
 1247               	.global	send_nibble
 1249               	send_nibble:
 1250               	.LFB125:
 512:quantum/quantum.c **** }
 513:quantum/quantum.c **** 
 514:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 515:quantum/quantum.c **** 
 516:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 517:quantum/quantum.c **** 
 518:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 519:quantum/quantum.c **** #  define COM1x1 COM1C1
 520:quantum/quantum.c **** #  define OCR1x  OCR1C
 521:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 522:quantum/quantum.c **** #  define COM1x1 COM1B1
 523:quantum/quantum.c **** #  define OCR1x  OCR1B
 524:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 525:quantum/quantum.c **** #  define COM1x1 COM1A1
 526:quantum/quantum.c **** #  define OCR1x  OCR1A
 527:quantum/quantum.c **** #else
 528:quantum/quantum.c **** #  error "Backlight pin not supported - use B5, B6, or B7"
 529:quantum/quantum.c **** #endif
 530:quantum/quantum.c **** 
 531:quantum/quantum.c **** __attribute__ ((weak))
 532:quantum/quantum.c **** void backlight_init_ports(void)
 533:quantum/quantum.c **** {
 534:quantum/quantum.c **** 
 535:quantum/quantum.c ****   // Setup backlight pin as output and output low.
 536:quantum/quantum.c ****   // DDRx |= n
 537:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 538:quantum/quantum.c ****   // PORTx &= ~n
 539:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 540:quantum/quantum.c **** 
 541:quantum/quantum.c ****   // Use full 16-bit resolution.
 542:quantum/quantum.c ****   ICR1 = 0xFFFF;
 543:quantum/quantum.c **** 
 544:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
 545:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
 546:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
 547:quantum/quantum.c **** 
 548:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
 549:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
 550:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
 551:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
 552:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
 553:quantum/quantum.c **** 
 554:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
 555:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
 556:quantum/quantum.c **** 
 557:quantum/quantum.c ****   backlight_init();
 558:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
 559:quantum/quantum.c ****     breathing_defaults();
 560:quantum/quantum.c ****   #endif
 561:quantum/quantum.c **** }
 562:quantum/quantum.c **** 
 563:quantum/quantum.c **** __attribute__ ((weak))
 564:quantum/quantum.c **** void backlight_set(uint8_t level)
 565:quantum/quantum.c **** {
 566:quantum/quantum.c ****   // Prevent backlight blink on lowest level
 567:quantum/quantum.c ****   // PORTx &= ~n
 568:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 569:quantum/quantum.c **** 
 570:quantum/quantum.c ****   if ( level == 0 ) {
 571:quantum/quantum.c ****     // Turn off PWM control on backlight pin, revert to output low.
 572:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 573:quantum/quantum.c ****     OCR1x = 0x0;
 574:quantum/quantum.c ****   } else if ( level == BACKLIGHT_LEVELS ) {
 575:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 576:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
 577:quantum/quantum.c ****     // Set the brightness
 578:quantum/quantum.c ****     OCR1x = 0xFFFF;
 579:quantum/quantum.c ****   } else {
 580:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 581:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
 582:quantum/quantum.c ****     // Set the brightness
 583:quantum/quantum.c ****     OCR1x = 0xFFFF >> ((BACKLIGHT_LEVELS - level) * ((BACKLIGHT_LEVELS + 1) / 2));
 584:quantum/quantum.c ****   }
 585:quantum/quantum.c **** 
 586:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
 587:quantum/quantum.c ****     breathing_intensity_default();
 588:quantum/quantum.c ****   #endif
 589:quantum/quantum.c **** }
 590:quantum/quantum.c **** 
 591:quantum/quantum.c **** 
 592:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 593:quantum/quantum.c **** 
 594:quantum/quantum.c **** #define BREATHING_NO_HALT  0
 595:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
 596:quantum/quantum.c **** #define BREATHING_HALT_ON  2
 597:quantum/quantum.c **** 
 598:quantum/quantum.c **** static uint8_t breath_intensity;
 599:quantum/quantum.c **** static uint8_t breath_speed;
 600:quantum/quantum.c **** static uint16_t breathing_index;
 601:quantum/quantum.c **** static uint8_t breathing_halt;
 602:quantum/quantum.c **** 
 603:quantum/quantum.c **** void breathing_enable(void)
 604:quantum/quantum.c **** {
 605:quantum/quantum.c ****     if (get_backlight_level() == 0)
 606:quantum/quantum.c ****     {
 607:quantum/quantum.c ****         breathing_index = 0;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c ****     else
 610:quantum/quantum.c ****     {
 611:quantum/quantum.c ****         // Set breathing_index to be at the midpoint (brightest point)
 612:quantum/quantum.c ****         breathing_index = 0x20 << breath_speed;
 613:quantum/quantum.c ****     }
 614:quantum/quantum.c **** 
 615:quantum/quantum.c ****     breathing_halt = BREATHING_NO_HALT;
 616:quantum/quantum.c **** 
 617:quantum/quantum.c ****     // Enable breathing interrupt
 618:quantum/quantum.c ****     TIMSK1 |= _BV(OCIE1A);
 619:quantum/quantum.c **** }
 620:quantum/quantum.c **** 
 621:quantum/quantum.c **** void breathing_pulse(void)
 622:quantum/quantum.c **** {
 623:quantum/quantum.c ****     if (get_backlight_level() == 0)
 624:quantum/quantum.c ****     {
 625:quantum/quantum.c ****         breathing_index = 0;
 626:quantum/quantum.c ****     }
 627:quantum/quantum.c ****     else
 628:quantum/quantum.c ****     {
 629:quantum/quantum.c ****         // Set breathing_index to be at the midpoint + 1 (brightest point)
 630:quantum/quantum.c ****         breathing_index = 0x21 << breath_speed;
 631:quantum/quantum.c ****     }
 632:quantum/quantum.c **** 
 633:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
 634:quantum/quantum.c **** 
 635:quantum/quantum.c ****     // Enable breathing interrupt
 636:quantum/quantum.c ****     TIMSK1 |= _BV(OCIE1A);
 637:quantum/quantum.c **** }
 638:quantum/quantum.c **** 
 639:quantum/quantum.c **** void breathing_disable(void)
 640:quantum/quantum.c **** {
 641:quantum/quantum.c ****     // Disable breathing interrupt
 642:quantum/quantum.c ****     TIMSK1 &= ~_BV(OCIE1A);
 643:quantum/quantum.c ****     backlight_set(get_backlight_level());
 644:quantum/quantum.c **** }
 645:quantum/quantum.c **** 
 646:quantum/quantum.c **** void breathing_self_disable(void)
 647:quantum/quantum.c **** {
 648:quantum/quantum.c ****     if (get_backlight_level() == 0)
 649:quantum/quantum.c ****     {
 650:quantum/quantum.c ****         breathing_halt = BREATHING_HALT_OFF;
 651:quantum/quantum.c ****     }
 652:quantum/quantum.c ****     else
 653:quantum/quantum.c ****     {
 654:quantum/quantum.c ****         breathing_halt = BREATHING_HALT_ON;
 655:quantum/quantum.c ****     }
 656:quantum/quantum.c **** 
 657:quantum/quantum.c ****     //backlight_set(get_backlight_level());
 658:quantum/quantum.c **** }
 659:quantum/quantum.c **** 
 660:quantum/quantum.c **** void breathing_toggle(void)
 661:quantum/quantum.c **** {
 662:quantum/quantum.c ****     if (!is_breathing())
 663:quantum/quantum.c ****     {
 664:quantum/quantum.c ****         if (get_backlight_level() == 0)
 665:quantum/quantum.c ****         {
 666:quantum/quantum.c ****             breathing_index = 0;
 667:quantum/quantum.c ****         }
 668:quantum/quantum.c ****         else
 669:quantum/quantum.c ****         {
 670:quantum/quantum.c ****             // Set breathing_index to be at the midpoint + 1 (brightest point)
 671:quantum/quantum.c ****             breathing_index = 0x21 << breath_speed;
 672:quantum/quantum.c ****         }
 673:quantum/quantum.c **** 
 674:quantum/quantum.c ****         breathing_halt = BREATHING_NO_HALT;
 675:quantum/quantum.c ****     }
 676:quantum/quantum.c **** 
 677:quantum/quantum.c ****     // Toggle breathing interrupt
 678:quantum/quantum.c ****     TIMSK1 ^= _BV(OCIE1A);
 679:quantum/quantum.c **** 
 680:quantum/quantum.c ****     // Restore backlight level
 681:quantum/quantum.c ****     if (!is_breathing())
 682:quantum/quantum.c ****     {
 683:quantum/quantum.c ****         backlight_set(get_backlight_level());
 684:quantum/quantum.c ****     }
 685:quantum/quantum.c **** }
 686:quantum/quantum.c **** 
 687:quantum/quantum.c **** bool is_breathing(void)
 688:quantum/quantum.c **** {
 689:quantum/quantum.c ****     return (TIMSK1 && _BV(OCIE1A));
 690:quantum/quantum.c **** }
 691:quantum/quantum.c **** 
 692:quantum/quantum.c **** void breathing_intensity_default(void)
 693:quantum/quantum.c **** {
 694:quantum/quantum.c ****     //breath_intensity = (uint8_t)((uint16_t)100 * (uint16_t)get_backlight_level() / (uint16_t)BACK
 695:quantum/quantum.c ****     breath_intensity = ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2));
 696:quantum/quantum.c **** }
 697:quantum/quantum.c **** 
 698:quantum/quantum.c **** void breathing_intensity_set(uint8_t value)
 699:quantum/quantum.c **** {
 700:quantum/quantum.c ****     breath_intensity = value;
 701:quantum/quantum.c **** }
 702:quantum/quantum.c **** 
 703:quantum/quantum.c **** void breathing_speed_default(void)
 704:quantum/quantum.c **** {
 705:quantum/quantum.c ****     breath_speed = 4;
 706:quantum/quantum.c **** }
 707:quantum/quantum.c **** 
 708:quantum/quantum.c **** void breathing_speed_set(uint8_t value)
 709:quantum/quantum.c **** {
 710:quantum/quantum.c ****     bool is_breathing_now = is_breathing();
 711:quantum/quantum.c ****     uint8_t old_breath_speed = breath_speed;
 712:quantum/quantum.c **** 
 713:quantum/quantum.c ****     if (is_breathing_now)
 714:quantum/quantum.c ****     {
 715:quantum/quantum.c ****         // Disable breathing interrupt
 716:quantum/quantum.c ****         TIMSK1 &= ~_BV(OCIE1A);
 717:quantum/quantum.c ****     }
 718:quantum/quantum.c **** 
 719:quantum/quantum.c ****     breath_speed = value;
 720:quantum/quantum.c **** 
 721:quantum/quantum.c ****     if (is_breathing_now)
 722:quantum/quantum.c ****     {
 723:quantum/quantum.c ****         // Adjust index to account for new speed
 724:quantum/quantum.c ****         breathing_index = (( (uint8_t)( (breathing_index) >> old_breath_speed ) ) & 0x3F) << breath
 725:quantum/quantum.c **** 
 726:quantum/quantum.c ****         // Enable breathing interrupt
 727:quantum/quantum.c ****         TIMSK1 |= _BV(OCIE1A);
 728:quantum/quantum.c ****     }
 729:quantum/quantum.c **** 
 730:quantum/quantum.c **** }
 731:quantum/quantum.c **** 
 732:quantum/quantum.c **** void breathing_speed_inc(uint8_t value)
 733:quantum/quantum.c **** {
 734:quantum/quantum.c ****     if ((uint16_t)(breath_speed - value) > 10 )
 735:quantum/quantum.c ****     {
 736:quantum/quantum.c ****         breathing_speed_set(0);
 737:quantum/quantum.c ****     }
 738:quantum/quantum.c ****     else
 739:quantum/quantum.c ****     {
 740:quantum/quantum.c ****         breathing_speed_set(breath_speed - value);
 741:quantum/quantum.c ****     }
 742:quantum/quantum.c **** }
 743:quantum/quantum.c **** 
 744:quantum/quantum.c **** void breathing_speed_dec(uint8_t value)
 745:quantum/quantum.c **** {
 746:quantum/quantum.c ****     if ((uint16_t)(breath_speed + value) > 10 )
 747:quantum/quantum.c ****     {
 748:quantum/quantum.c ****         breathing_speed_set(10);
 749:quantum/quantum.c ****     }
 750:quantum/quantum.c ****     else
 751:quantum/quantum.c ****     {
 752:quantum/quantum.c ****         breathing_speed_set(breath_speed + value);
 753:quantum/quantum.c ****     }
 754:quantum/quantum.c **** }
 755:quantum/quantum.c **** 
 756:quantum/quantum.c **** void breathing_defaults(void)
 757:quantum/quantum.c **** {
 758:quantum/quantum.c ****     breathing_intensity_default();
 759:quantum/quantum.c ****     breathing_speed_default();
 760:quantum/quantum.c ****     breathing_halt = BREATHING_NO_HALT;
 761:quantum/quantum.c **** }
 762:quantum/quantum.c **** 
 763:quantum/quantum.c **** /* Breathing Sleep LED brighness(PWM On period) table
 764:quantum/quantum.c ****  * (64[steps] * 4[duration]) / 64[PWM periods/s] = 4 second breath cycle
 765:quantum/quantum.c ****  *
 766:quantum/quantum.c ****  * http://www.wolframalpha.com/input/?i=%28sin%28+x%2F64*pi%29**8+*+255%2C+x%3D0+to+63
 767:quantum/quantum.c ****  * (0..63).each {|x| p ((sin(x/64.0*PI)**8)*255).to_i }
 768:quantum/quantum.c ****  */
 769:quantum/quantum.c **** static const uint8_t breathing_table[64] PROGMEM = {
 770:quantum/quantum.c ****   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   4,   6,  10,
 771:quantum/quantum.c ****  15,  23,  32,  44,  58,  74,  93, 113, 135, 157, 179, 199, 218, 233, 245, 252,
 772:quantum/quantum.c **** 255, 252, 245, 233, 218, 199, 179, 157, 135, 113,  93,  74,  58,  44,  32,  23,
 773:quantum/quantum.c ****  15,  10,   6,   4,   2,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 774:quantum/quantum.c **** };
 775:quantum/quantum.c **** 
 776:quantum/quantum.c **** ISR(TIMER1_COMPA_vect)
 777:quantum/quantum.c **** {
 778:quantum/quantum.c ****     // OCR1x = (pgm_read_byte(&breathing_table[ ( (uint8_t)( (breathing_index++) >> breath_speed ) 
 779:quantum/quantum.c **** 
 780:quantum/quantum.c **** 
 781:quantum/quantum.c ****     uint8_t local_index = ( (uint8_t)( (breathing_index++) >> breath_speed ) ) & 0x3F;
 782:quantum/quantum.c **** 
 783:quantum/quantum.c ****     if (((breathing_halt == BREATHING_HALT_ON) && (local_index == 0x20)) || ((breathing_halt == BRE
 784:quantum/quantum.c ****     {
 785:quantum/quantum.c ****         // Disable breathing interrupt
 786:quantum/quantum.c ****         TIMSK1 &= ~_BV(OCIE1A);
 787:quantum/quantum.c ****     }
 788:quantum/quantum.c **** 
 789:quantum/quantum.c ****     OCR1x = (uint16_t)(((uint16_t)pgm_read_byte(&breathing_table[local_index]) * 257)) >> breath_in
 790:quantum/quantum.c **** 
 791:quantum/quantum.c **** }
 792:quantum/quantum.c **** 
 793:quantum/quantum.c **** 
 794:quantum/quantum.c **** 
 795:quantum/quantum.c **** #endif // breathing
 796:quantum/quantum.c **** 
 797:quantum/quantum.c **** #else // backlight
 798:quantum/quantum.c **** 
 799:quantum/quantum.c **** __attribute__ ((weak))
 800:quantum/quantum.c **** void backlight_init_ports(void)
 801:quantum/quantum.c **** {
 802:quantum/quantum.c **** 
 803:quantum/quantum.c **** }
 804:quantum/quantum.c **** 
 805:quantum/quantum.c **** __attribute__ ((weak))
 806:quantum/quantum.c **** void backlight_set(uint8_t level)
 807:quantum/quantum.c **** {
 808:quantum/quantum.c **** 
 809:quantum/quantum.c **** }
 810:quantum/quantum.c **** 
 811:quantum/quantum.c **** #endif // backlight
 812:quantum/quantum.c **** 
 813:quantum/quantum.c **** 
 814:quantum/quantum.c **** // Functions for spitting out values
 815:quantum/quantum.c **** //
 816:quantum/quantum.c **** 
 817:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
 818:quantum/quantum.c ****     uint16_t word = (number >> 16);
 819:quantum/quantum.c ****     send_word(word);
 820:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 821:quantum/quantum.c **** }
 822:quantum/quantum.c **** 
 823:quantum/quantum.c **** void send_word(uint16_t number) {
 824:quantum/quantum.c ****     uint8_t byte = number >> 8;
 825:quantum/quantum.c ****     send_byte(byte);
 826:quantum/quantum.c ****     send_byte(number & 0xFF);
 827:quantum/quantum.c **** }
 828:quantum/quantum.c **** 
 829:quantum/quantum.c **** void send_byte(uint8_t number) {
 830:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 831:quantum/quantum.c ****     send_nibble(nibble);
 832:quantum/quantum.c ****     send_nibble(number & 0xF);
 833:quantum/quantum.c **** }
 834:quantum/quantum.c **** 
 835:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1251               		.loc 1 835 0
 1252               		.cfi_startproc
 1253               	.LVL117:
 1254               		.loc 1 835 0
 1255 0000 CF93      		push r28
 1256               	.LCFI23:
 1257               		.cfi_def_cfa_offset 3
 1258               		.cfi_offset 28, -2
 1259               	/* prologue: function */
 1260               	/* frame size = 0 */
 1261               	/* stack size = 1 */
 1262               	.L__stack_usage = 1
 836:quantum/quantum.c ****     switch (number) {
 1263               		.loc 1 836 0
 1264 0002 8A30      		cpi r24,lo8(10)
 1265 0004 00F4      		brsh .L163
 1266 0006 8130      		cpi r24,lo8(1)
 1267 0008 00F4      		brsh .L171
 837:quantum/quantum.c ****         case 0:
 838:quantum/quantum.c ****             register_code(KC_0);
 1268               		.loc 1 838 0
 1269 000a 87E2      		ldi r24,lo8(39)
 1270               	.LVL118:
 1271 000c 0E94 0000 		call register_code
 1272               	.LVL119:
 839:quantum/quantum.c ****             unregister_code(KC_0);
 1273               		.loc 1 839 0
 1274 0010 87E2      		ldi r24,lo8(39)
 1275 0012 00C0      		rjmp .L169
 1276               	.LVL120:
 1277               	.L163:
 836:quantum/quantum.c ****     switch (number) {
 1278               		.loc 1 836 0
 1279 0014 8031      		cpi r24,lo8(16)
 1280 0016 00F4      		brsh .L172
 840:quantum/quantum.c ****             break;
 841:quantum/quantum.c ****         case 1 ... 9:
 842:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 843:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 844:quantum/quantum.c ****             break;
 845:quantum/quantum.c ****         case 0xA ... 0xF:
 846:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1281               		.loc 1 846 0
 1282 0018 CAEF      		ldi r28,lo8(-6)
 1283 001a 00C0      		rjmp .L170
 1284               	.L171:
 842:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 1285               		.loc 1 842 0
 1286 001c CDE1      		ldi r28,lo8(29)
 1287               	.L170:
 1288               		.loc 1 846 0
 1289 001e C80F      		add r28,r24
 1290 0020 8C2F      		mov r24,r28
 1291               	.LVL121:
 1292 0022 0E94 0000 		call register_code
 1293               	.LVL122:
 847:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1294               		.loc 1 847 0
 1295 0026 8C2F      		mov r24,r28
 1296               	.L169:
 1297               	/* epilogue start */
 848:quantum/quantum.c ****             break;
 849:quantum/quantum.c ****     }
 850:quantum/quantum.c **** }
 1298               		.loc 1 850 0
 1299 0028 CF91      		pop r28
 847:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1300               		.loc 1 847 0
 1301 002a 0C94 0000 		jmp unregister_code
 1302               	.LVL123:
 1303               	.L172:
 1304               	/* epilogue start */
 1305               		.loc 1 850 0
 1306 002e CF91      		pop r28
 1307 0030 0895      		ret
 1308               		.cfi_endproc
 1309               	.LFE125:
 1311               		.section	.text.send_byte,"ax",@progbits
 1312               	.global	send_byte
 1314               	send_byte:
 1315               	.LFB124:
 829:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1316               		.loc 1 829 0
 1317               		.cfi_startproc
 1318               	.LVL124:
 1319 0000 CF93      		push r28
 1320               	.LCFI24:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 28, -2
 1323               	/* prologue: function */
 1324               	/* frame size = 0 */
 1325               	/* stack size = 1 */
 1326               	.L__stack_usage = 1
 1327 0002 C82F      		mov r28,r24
 1328               	.LVL125:
 831:quantum/quantum.c ****     send_nibble(number & 0xF);
 1329               		.loc 1 831 0
 1330 0004 8295      		swap r24
 1331               	.LVL126:
 1332 0006 8F70      		andi r24,lo8(15)
 1333 0008 0E94 0000 		call send_nibble
 1334               	.LVL127:
 832:quantum/quantum.c **** }
 1335               		.loc 1 832 0
 1336 000c 8C2F      		mov r24,r28
 1337 000e 8F70      		andi r24,lo8(15)
 1338               	/* epilogue start */
 833:quantum/quantum.c **** 
 1339               		.loc 1 833 0
 1340 0010 CF91      		pop r28
 1341               	.LVL128:
 832:quantum/quantum.c **** }
 1342               		.loc 1 832 0
 1343 0012 0C94 0000 		jmp send_nibble
 1344               	.LVL129:
 1345               		.cfi_endproc
 1346               	.LFE124:
 1348               		.section	.text.send_word,"ax",@progbits
 1349               	.global	send_word
 1351               	send_word:
 1352               	.LFB123:
 823:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1353               		.loc 1 823 0
 1354               		.cfi_startproc
 1355               	.LVL130:
 1356 0000 CF93      		push r28
 1357               	.LCFI25:
 1358               		.cfi_def_cfa_offset 3
 1359               		.cfi_offset 28, -2
 1360               	/* prologue: function */
 1361               	/* frame size = 0 */
 1362               	/* stack size = 1 */
 1363               	.L__stack_usage = 1
 1364 0002 C82F      		mov r28,r24
 1365               	.LVL131:
 825:quantum/quantum.c ****     send_byte(number & 0xFF);
 1366               		.loc 1 825 0
 1367 0004 892F      		mov r24,r25
 1368               	.LVL132:
 1369 0006 0E94 0000 		call send_byte
 1370               	.LVL133:
 826:quantum/quantum.c **** }
 1371               		.loc 1 826 0
 1372 000a 8C2F      		mov r24,r28
 1373               	/* epilogue start */
 827:quantum/quantum.c **** 
 1374               		.loc 1 827 0
 1375 000c CF91      		pop r28
 826:quantum/quantum.c **** }
 1376               		.loc 1 826 0
 1377 000e 0C94 0000 		jmp send_byte
 1378               	.LVL134:
 1379               		.cfi_endproc
 1380               	.LFE123:
 1382               		.section	.text.send_dword,"ax",@progbits
 1383               	.global	send_dword
 1385               	send_dword:
 1386               	.LFB122:
 817:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1387               		.loc 1 817 0
 1388               		.cfi_startproc
 1389               	.LVL135:
 1390 0000 CF92      		push r12
 1391               	.LCFI26:
 1392               		.cfi_def_cfa_offset 3
 1393               		.cfi_offset 12, -2
 1394 0002 DF92      		push r13
 1395               	.LCFI27:
 1396               		.cfi_def_cfa_offset 4
 1397               		.cfi_offset 13, -3
 1398 0004 EF92      		push r14
 1399               	.LCFI28:
 1400               		.cfi_def_cfa_offset 5
 1401               		.cfi_offset 14, -4
 1402 0006 FF92      		push r15
 1403               	.LCFI29:
 1404               		.cfi_def_cfa_offset 6
 1405               		.cfi_offset 15, -5
 1406               	/* prologue: function */
 1407               	/* frame size = 0 */
 1408               	/* stack size = 4 */
 1409               	.L__stack_usage = 4
 1410 0008 6B01      		movw r12,r22
 1411 000a 7C01      		movw r14,r24
 1412               	.LVL136:
 819:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1413               		.loc 1 819 0
 1414 000c C701      		movw r24,r14
 1415 000e 0E94 0000 		call send_word
 1416               	.LVL137:
 820:quantum/quantum.c **** }
 1417               		.loc 1 820 0
 1418 0012 C601      		movw r24,r12
 1419               	/* epilogue start */
 821:quantum/quantum.c **** 
 1420               		.loc 1 821 0
 1421 0014 FF90      		pop r15
 1422 0016 EF90      		pop r14
 1423 0018 DF90      		pop r13
 1424 001a CF90      		pop r12
 1425               	.LVL138:
 820:quantum/quantum.c **** }
 1426               		.loc 1 820 0
 1427 001c 0C94 0000 		jmp send_word
 1428               	.LVL139:
 1429               		.cfi_endproc
 1430               	.LFE122:
 1432               		.section	.text.api_send_unicode,"ax",@progbits
 1433               	.global	api_send_unicode
 1435               	api_send_unicode:
 1436               	.LFB126:
 851:quantum/quantum.c **** 
 852:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1437               		.loc 1 852 0
 1438               		.cfi_startproc
 1439               	.LVL140:
 1440               	/* prologue: function */
 1441               	/* frame size = 0 */
 1442               	/* stack size = 0 */
 1443               	.L__stack_usage = 0
 1444 0000 0895      		ret
 1445               		.cfi_endproc
 1446               	.LFE126:
 1448               		.section	.text.led_set_user,"ax",@progbits
 1449               		.weak	led_set_user
 1451               	led_set_user:
 1452               	.LFB127:
 853:quantum/quantum.c **** #ifdef API_ENABLE
 854:quantum/quantum.c ****     uint8_t chunk[4];
 855:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
 856:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
 857:quantum/quantum.c **** #endif
 858:quantum/quantum.c **** }
 859:quantum/quantum.c **** 
 860:quantum/quantum.c **** __attribute__ ((weak))
 861:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 1453               		.loc 1 861 0
 1454               		.cfi_startproc
 1455               	.LVL141:
 1456               	/* prologue: function */
 1457               	/* frame size = 0 */
 1458               	/* stack size = 0 */
 1459               	.L__stack_usage = 0
 1460 0000 0895      		ret
 1461               		.cfi_endproc
 1462               	.LFE127:
 1464               		.set	led_set_user.localalias.1,led_set_user
 1465               		.section	.text.backlight_set,"ax",@progbits
 1466               		.weak	backlight_set
 1468               	backlight_set:
 1469               	.LFB140:
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 1475 0000 0C94 0000 		jmp led_set_user.localalias.1
 1476               		.cfi_endproc
 1477               	.LFE140:
 1479               		.section	.text.led_set_kb,"ax",@progbits
 1480               		.weak	led_set_kb
 1482               	led_set_kb:
 1483               	.LFB128:
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** }
 864:quantum/quantum.c **** 
 865:quantum/quantum.c **** __attribute__ ((weak))
 866:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 1484               		.loc 1 866 0
 1485               		.cfi_startproc
 1486               	.LVL142:
 1487               	/* prologue: function */
 1488               	/* frame size = 0 */
 1489               	/* stack size = 0 */
 1490               	.L__stack_usage = 0
 867:quantum/quantum.c ****     led_set_user(usb_led);
 1491               		.loc 1 867 0
 1492 0000 0C94 0000 		jmp led_set_user
 1493               	.LVL143:
 1494               		.cfi_endproc
 1495               	.LFE128:
 1497               		.section	.text.led_init_ports,"ax",@progbits
 1498               		.weak	led_init_ports
 1500               	led_init_ports:
 1501               	.LFB136:
 1502               		.cfi_startproc
 1503               	/* prologue: function */
 1504               	/* frame size = 0 */
 1505               	/* stack size = 0 */
 1506               	.L__stack_usage = 0
 1507 0000 0895      		ret
 1508               		.cfi_endproc
 1509               	.LFE136:
 1511               		.section	.text.led_set,"ax",@progbits
 1512               		.weak	led_set
 1514               	led_set:
 1515               	.LFB130:
 868:quantum/quantum.c **** }
 869:quantum/quantum.c **** 
 870:quantum/quantum.c **** __attribute__ ((weak))
 871:quantum/quantum.c **** void led_init_ports(void)
 872:quantum/quantum.c **** {
 873:quantum/quantum.c **** 
 874:quantum/quantum.c **** }
 875:quantum/quantum.c **** 
 876:quantum/quantum.c **** __attribute__ ((weak))
 877:quantum/quantum.c **** void led_set(uint8_t usb_led)
 878:quantum/quantum.c **** {
 1516               		.loc 1 878 0
 1517               		.cfi_startproc
 1518               	.LVL144:
 1519               	/* prologue: function */
 1520               	/* frame size = 0 */
 1521               	/* stack size = 0 */
 1522               	.L__stack_usage = 0
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   // Example LED Code
 881:quantum/quantum.c ****   //
 882:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
 883:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
 884:quantum/quantum.c ****     // {
 885:quantum/quantum.c ****     //     // Output high.
 886:quantum/quantum.c ****     //     DDRE |= (1<<6);
 887:quantum/quantum.c ****     //     PORTE |= (1<<6);
 888:quantum/quantum.c ****     // }
 889:quantum/quantum.c ****     // else
 890:quantum/quantum.c ****     // {
 891:quantum/quantum.c ****     //     // Output low.
 892:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
 893:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
 894:quantum/quantum.c ****     // }
 895:quantum/quantum.c **** 
 896:quantum/quantum.c ****   led_set_kb(usb_led);
 1523               		.loc 1 896 0
 1524 0000 0C94 0000 		jmp led_set_kb
 1525               	.LVL145:
 1526               		.cfi_endproc
 1527               	.LFE130:
 1529               		.section	.text.startup_user,"ax",@progbits
 1530               		.weak	startup_user
 1532               	startup_user:
 1533               	.LFB134:
 1534               		.cfi_startproc
 1535               	/* prologue: function */
 1536               	/* frame size = 0 */
 1537               	/* stack size = 0 */
 1538               	.L__stack_usage = 0
 1539 0000 0895      		ret
 1540               		.cfi_endproc
 1541               	.LFE134:
 1543               		.section	.text.shutdown_user,"ax",@progbits
 1544               		.weak	shutdown_user
 1546               	shutdown_user:
 1547               	.LFB132:
 897:quantum/quantum.c **** }
 898:quantum/quantum.c **** 
 899:quantum/quantum.c **** 
 900:quantum/quantum.c **** //------------------------------------------------------------------------------
 901:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
 902:quantum/quantum.c **** // different events such as startup and bootloader jump
 903:quantum/quantum.c **** 
 904:quantum/quantum.c **** __attribute__ ((weak))
 905:quantum/quantum.c **** void startup_user() {}
 906:quantum/quantum.c **** 
 907:quantum/quantum.c **** __attribute__ ((weak))
 908:quantum/quantum.c **** void shutdown_user() {}
 1548               		.loc 1 908 0
 1549               		.cfi_startproc
 1550               	/* prologue: function */
 1551               	/* frame size = 0 */
 1552               	/* stack size = 0 */
 1553               	.L__stack_usage = 0
 1554 0000 0895      		ret
 1555               		.cfi_endproc
 1556               	.LFE132:
 1558               	.global	ascii_to_qwerty_keycode_lut
 1559               		.section	.progmem.data.ascii_to_qwerty_keycode_lut,"a",@progbits
 1562               	ascii_to_qwerty_keycode_lut:
 1563 0000 00        		.byte	0
 1564 0001 00        		.byte	0
 1565 0002 00        		.byte	0
 1566 0003 00        		.byte	0
 1567 0004 00        		.byte	0
 1568 0005 00        		.byte	0
 1569 0006 00        		.byte	0
 1570 0007 00        		.byte	0
 1571 0008 2A        		.byte	42
 1572 0009 2B        		.byte	43
 1573 000a 28        		.byte	40
 1574 000b 00        		.byte	0
 1575 000c 00        		.byte	0
 1576 000d 00        		.byte	0
 1577 000e 00        		.byte	0
 1578 000f 00        		.byte	0
 1579 0010 00        		.byte	0
 1580 0011 00        		.byte	0
 1581 0012 00        		.byte	0
 1582 0013 00        		.byte	0
 1583 0014 00        		.byte	0
 1584 0015 00        		.byte	0
 1585 0016 00        		.byte	0
 1586 0017 00        		.byte	0
 1587 0018 00        		.byte	0
 1588 0019 00        		.byte	0
 1589 001a 00        		.byte	0
 1590 001b 29        		.byte	41
 1591 001c 00        		.byte	0
 1592 001d 00        		.byte	0
 1593 001e 00        		.byte	0
 1594 001f 00        		.byte	0
 1595 0020 2C        		.byte	44
 1596 0021 1E        		.byte	30
 1597 0022 34        		.byte	52
 1598 0023 20        		.byte	32
 1599 0024 21        		.byte	33
 1600 0025 22        		.byte	34
 1601 0026 24        		.byte	36
 1602 0027 34        		.byte	52
 1603 0028 26        		.byte	38
 1604 0029 27        		.byte	39
 1605 002a 25        		.byte	37
 1606 002b 2E        		.byte	46
 1607 002c 36        		.byte	54
 1608 002d 2D        		.byte	45
 1609 002e 37        		.byte	55
 1610 002f 38        		.byte	56
 1611 0030 27        		.byte	39
 1612 0031 1E        		.byte	30
 1613 0032 1F        		.byte	31
 1614 0033 20        		.byte	32
 1615 0034 21        		.byte	33
 1616 0035 22        		.byte	34
 1617 0036 23        		.byte	35
 1618 0037 24        		.byte	36
 1619 0038 25        		.byte	37
 1620 0039 26        		.byte	38
 1621 003a 33        		.byte	51
 1622 003b 33        		.byte	51
 1623 003c 36        		.byte	54
 1624 003d 2E        		.byte	46
 1625 003e 37        		.byte	55
 1626 003f 38        		.byte	56
 1627 0040 1F        		.byte	31
 1628 0041 04        		.byte	4
 1629 0042 05        		.byte	5
 1630 0043 06        		.byte	6
 1631 0044 07        		.byte	7
 1632 0045 08        		.byte	8
 1633 0046 09        		.byte	9
 1634 0047 0A        		.byte	10
 1635 0048 0B        		.byte	11
 1636 0049 0C        		.byte	12
 1637 004a 0D        		.byte	13
 1638 004b 0E        		.byte	14
 1639 004c 0F        		.byte	15
 1640 004d 10        		.byte	16
 1641 004e 11        		.byte	17
 1642 004f 12        		.byte	18
 1643 0050 13        		.byte	19
 1644 0051 14        		.byte	20
 1645 0052 15        		.byte	21
 1646 0053 16        		.byte	22
 1647 0054 17        		.byte	23
 1648 0055 18        		.byte	24
 1649 0056 19        		.byte	25
 1650 0057 1A        		.byte	26
 1651 0058 1B        		.byte	27
 1652 0059 1C        		.byte	28
 1653 005a 1D        		.byte	29
 1654 005b 2F        		.byte	47
 1655 005c 31        		.byte	49
 1656 005d 30        		.byte	48
 1657 005e 23        		.byte	35
 1658 005f 2D        		.byte	45
 1659 0060 35        		.byte	53
 1660 0061 04        		.byte	4
 1661 0062 05        		.byte	5
 1662 0063 06        		.byte	6
 1663 0064 07        		.byte	7
 1664 0065 08        		.byte	8
 1665 0066 09        		.byte	9
 1666 0067 0A        		.byte	10
 1667 0068 0B        		.byte	11
 1668 0069 0C        		.byte	12
 1669 006a 0D        		.byte	13
 1670 006b 0E        		.byte	14
 1671 006c 0F        		.byte	15
 1672 006d 10        		.byte	16
 1673 006e 11        		.byte	17
 1674 006f 12        		.byte	18
 1675 0070 13        		.byte	19
 1676 0071 14        		.byte	20
 1677 0072 15        		.byte	21
 1678 0073 16        		.byte	22
 1679 0074 17        		.byte	23
 1680 0075 18        		.byte	24
 1681 0076 19        		.byte	25
 1682 0077 1A        		.byte	26
 1683 0078 1B        		.byte	27
 1684 0079 1C        		.byte	28
 1685 007a 1D        		.byte	29
 1686 007b 2F        		.byte	47
 1687 007c 31        		.byte	49
 1688 007d 30        		.byte	48
 1689 007e 35        		.byte	53
 1690 007f 4C        		.byte	76
 1691               	.global	ascii_to_qwerty_shift_lut
 1692               		.section	.progmem.data.ascii_to_qwerty_shift_lut,"a",@progbits
 1695               	ascii_to_qwerty_shift_lut:
 1696 0000 00        		.byte	0
 1697 0001 00        		.byte	0
 1698 0002 00        		.byte	0
 1699 0003 00        		.byte	0
 1700 0004 00        		.byte	0
 1701 0005 00        		.byte	0
 1702 0006 00        		.byte	0
 1703 0007 00        		.byte	0
 1704 0008 00        		.byte	0
 1705 0009 00        		.byte	0
 1706 000a 00        		.byte	0
 1707 000b 00        		.byte	0
 1708 000c 00        		.byte	0
 1709 000d 00        		.byte	0
 1710 000e 00        		.byte	0
 1711 000f 00        		.byte	0
 1712 0010 00        		.byte	0
 1713 0011 00        		.byte	0
 1714 0012 00        		.byte	0
 1715 0013 00        		.byte	0
 1716 0014 00        		.byte	0
 1717 0015 00        		.byte	0
 1718 0016 00        		.byte	0
 1719 0017 00        		.byte	0
 1720 0018 00        		.byte	0
 1721 0019 00        		.byte	0
 1722 001a 00        		.byte	0
 1723 001b 00        		.byte	0
 1724 001c 00        		.byte	0
 1725 001d 00        		.byte	0
 1726 001e 00        		.byte	0
 1727 001f 00        		.byte	0
 1728 0020 00        		.byte	0
 1729 0021 01        		.byte	1
 1730 0022 01        		.byte	1
 1731 0023 01        		.byte	1
 1732 0024 01        		.byte	1
 1733 0025 01        		.byte	1
 1734 0026 01        		.byte	1
 1735 0027 00        		.byte	0
 1736 0028 01        		.byte	1
 1737 0029 01        		.byte	1
 1738 002a 01        		.byte	1
 1739 002b 01        		.byte	1
 1740 002c 00        		.byte	0
 1741 002d 00        		.byte	0
 1742 002e 00        		.byte	0
 1743 002f 00        		.byte	0
 1744 0030 00        		.byte	0
 1745 0031 00        		.byte	0
 1746 0032 00        		.byte	0
 1747 0033 00        		.byte	0
 1748 0034 00        		.byte	0
 1749 0035 00        		.byte	0
 1750 0036 00        		.byte	0
 1751 0037 00        		.byte	0
 1752 0038 00        		.byte	0
 1753 0039 00        		.byte	0
 1754 003a 01        		.byte	1
 1755 003b 00        		.byte	0
 1756 003c 01        		.byte	1
 1757 003d 00        		.byte	0
 1758 003e 01        		.byte	1
 1759 003f 01        		.byte	1
 1760 0040 01        		.byte	1
 1761 0041 01        		.byte	1
 1762 0042 01        		.byte	1
 1763 0043 01        		.byte	1
 1764 0044 01        		.byte	1
 1765 0045 01        		.byte	1
 1766 0046 01        		.byte	1
 1767 0047 01        		.byte	1
 1768 0048 01        		.byte	1
 1769 0049 01        		.byte	1
 1770 004a 01        		.byte	1
 1771 004b 01        		.byte	1
 1772 004c 01        		.byte	1
 1773 004d 01        		.byte	1
 1774 004e 01        		.byte	1
 1775 004f 01        		.byte	1
 1776 0050 01        		.byte	1
 1777 0051 01        		.byte	1
 1778 0052 01        		.byte	1
 1779 0053 01        		.byte	1
 1780 0054 01        		.byte	1
 1781 0055 01        		.byte	1
 1782 0056 01        		.byte	1
 1783 0057 01        		.byte	1
 1784 0058 01        		.byte	1
 1785 0059 01        		.byte	1
 1786 005a 01        		.byte	1
 1787 005b 00        		.byte	0
 1788 005c 00        		.byte	0
 1789 005d 00        		.byte	0
 1790 005e 01        		.byte	1
 1791 005f 01        		.byte	1
 1792 0060 00        		.byte	0
 1793 0061 00        		.byte	0
 1794 0062 00        		.byte	0
 1795 0063 00        		.byte	0
 1796 0064 00        		.byte	0
 1797 0065 00        		.byte	0
 1798 0066 00        		.byte	0
 1799 0067 00        		.byte	0
 1800 0068 00        		.byte	0
 1801 0069 00        		.byte	0
 1802 006a 00        		.byte	0
 1803 006b 00        		.byte	0
 1804 006c 00        		.byte	0
 1805 006d 00        		.byte	0
 1806 006e 00        		.byte	0
 1807 006f 00        		.byte	0
 1808 0070 00        		.byte	0
 1809 0071 00        		.byte	0
 1810 0072 00        		.byte	0
 1811 0073 00        		.byte	0
 1812 0074 00        		.byte	0
 1813 0075 00        		.byte	0
 1814 0076 00        		.byte	0
 1815 0077 00        		.byte	0
 1816 0078 00        		.byte	0
 1817 0079 00        		.byte	0
 1818 007a 00        		.byte	0
 1819 007b 01        		.byte	1
 1820 007c 01        		.byte	1
 1821 007d 01        		.byte	1
 1822 007e 01        		.byte	1
 1823 007f 00        		.byte	0
 1824               		.section	.bss.scs_timer,"aw",@nobits
 1827               	scs_timer:
 1828 0000 0000      		.zero	2
 1829               		.section	.bss.shift_interrupted,"aw",@nobits
 1832               	shift_interrupted:
 1833 0000 0000      		.zero	2
 1834               		.text
 1835               	.Letext0:
 1836               		.file 3 "/usr/lib/avr/include/stdint.h"
 1837               		.file 4 "./tmk_core/common/keyboard.h"
 1838               		.file 5 "./tmk_core/common/action.h"
 1839               		.file 6 "./tmk_core/common/debug.h"
 1840               		.file 7 "quantum/keycode_config.h"
 1841               		.file 8 "./tmk_core/common/keycode.h"
 1842               		.file 9 "quantum/quantum_keycodes.h"
 1843               		.file 10 "./tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 1844               		.file 11 "quantum/quantum.h"
 1845               		.file 12 "./tmk_core/common/bootloader.h"
 1846               		.file 13 "./tmk_core/common/action_layer.h"
 1847               		.file 14 "quantum/keymap.h"
 1848               		.file 15 "./quantum/process_keycode/process_leader.h"
 1849               		.file 16 "quantum/rgblight.h"
 1850               		.file 17 "./tmk_core/common/eeconfig.h"
 1851               		.file 18 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccPVR985.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPVR985.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPVR985.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPVR985.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPVR985.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPVR985.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccPVR985.s:130    .text.register_code16:0000000000000000 register_code16
     /tmp/ccPVR985.s:163    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccPVR985.s:202    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccPVR985.s:221    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccPVR985.s:240    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccPVR985.s:258    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccPVR985.s:294    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccPVR985.s:1832   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccPVR985.s:1827   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccPVR985.s:845    .text.send_string:0000000000000000 send_string
     /tmp/ccPVR985.s:1562   .progmem.data.ascii_to_qwerty_keycode_lut:0000000000000000 ascii_to_qwerty_keycode_lut
     /tmp/ccPVR985.s:1695   .progmem.data.ascii_to_qwerty_shift_lut:0000000000000000 ascii_to_qwerty_shift_lut
     /tmp/ccPVR985.s:965    .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccPVR985.s:1074   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccPVR985.s:1201   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccPVR985.s:1218   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccPVR985.s:1235   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccPVR985.s:1249   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccPVR985.s:1314   .text.send_byte:0000000000000000 send_byte
     /tmp/ccPVR985.s:1351   .text.send_word:0000000000000000 send_word
     /tmp/ccPVR985.s:1385   .text.send_dword:0000000000000000 send_dword
     /tmp/ccPVR985.s:1435   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccPVR985.s:1451   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccPVR985.s:1451   .text.led_set_user:0000000000000000 led_set_user.localalias.1
     /tmp/ccPVR985.s:1468   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccPVR985.s:1482   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccPVR985.s:1500   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccPVR985.s:1514   .text.led_set:0000000000000000 led_set
     /tmp/ccPVR985.s:1532   .text.startup_user:0000000000000000 startup_user
     /tmp/ccPVR985.s:1546   .text.shutdown_user:0000000000000000 shutdown_user

UNDEFINED SYMBOLS
register_code
unregister_code
clear_keyboard
bootloader_jump
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
process_leader
rgblight_increase_hue
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
rgblight_toggle
rgblight_step
rgblight_increase_val
rgblight_increase_sat
rgblight_decrease_hue
rgblight_decrease_sat
timer_read
timer_elapsed
register_mods
unregister_mods
rgblight_decrease_val
layer_state
layer_on
layer_off
matrix_init_kb
matrix_scan_kb
__do_clear_bss
