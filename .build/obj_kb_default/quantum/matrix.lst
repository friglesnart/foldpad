   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_scan_user,"ax",@progbits
  11               		.weak	matrix_scan_user
  13               	matrix_scan_user:
  14               	.LFB11:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012 Jun Wako
   3:quantum/matrix.c **** Copyright 2014 Jack Humbert
   4:quantum/matrix.c **** 
   5:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   6:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   7:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   8:quantum/matrix.c **** (at your option) any later version.
   9:quantum/matrix.c **** 
  10:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  11:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  12:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13:quantum/matrix.c **** GNU General Public License for more details.
  14:quantum/matrix.c **** 
  15:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  16:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  17:quantum/matrix.c **** */
  18:quantum/matrix.c **** #include <stdint.h>
  19:quantum/matrix.c **** #include <stdbool.h>
  20:quantum/matrix.c **** #if defined(__AVR__)
  21:quantum/matrix.c **** #include <avr/io.h>
  22:quantum/matrix.c **** #endif
  23:quantum/matrix.c **** #include "wait.h"
  24:quantum/matrix.c **** #include "print.h"
  25:quantum/matrix.c **** #include "debug.h"
  26:quantum/matrix.c **** #include "util.h"
  27:quantum/matrix.c **** #include "matrix.h"
  28:quantum/matrix.c **** #include "timer.h"
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  34:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  35:quantum/matrix.c **** #endif
  36:quantum/matrix.c **** 
  37:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  38:quantum/matrix.c ****     static uint16_t debouncing_time;
  39:quantum/matrix.c ****     static bool debouncing = false;
  40:quantum/matrix.c **** #endif
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  43:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  44:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  45:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  46:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  47:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  48:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  49:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  50:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  51:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  52:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  53:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  54:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  55:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  56:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  57:quantum/matrix.c **** #endif
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** #ifdef MATRIX_MASKED
  60:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  61:quantum/matrix.c **** #endif
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** 
  66:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  67:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** static matrix_row_t matrix_raw[MATRIX_ROWS];
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #else // ROW2COL
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
 109:quantum/matrix.c **** }
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
  16               		.loc 1 112 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE11:
  26               		.set	matrix_scan_user.localalias.0,matrix_scan_user
  27               		.section	.text.matrix_init_user,"ax",@progbits
  28               		.weak	matrix_init_user
  30               	matrix_init_user:
  31               	.LFB29:
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  37 0000 0C94 0000 		jmp matrix_scan_user.localalias.0
  38               		.cfi_endproc
  39               	.LFE29:
  41               		.section	.text.matrix_init_kb,"ax",@progbits
  42               		.weak	matrix_init_kb
  44               	matrix_init_kb:
  45               	.LFB8:
  98:quantum/matrix.c ****     matrix_init_user();
  46               		.loc 1 98 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  52               		.loc 1 99 0
  53 0000 0C94 0000 		jmp matrix_init_user
  54               	.LVL0:
  55               		.cfi_endproc
  56               	.LFE8:
  58               		.section	.text.matrix_init_quantum,"ax",@progbits
  59               		.weak	matrix_init_quantum
  61               	matrix_init_quantum:
  62               	.LFB6:
  88:quantum/matrix.c ****     matrix_init_kb();
  63               		.loc 1 88 0
  64               		.cfi_startproc
  65               	/* prologue: function */
  66               	/* frame size = 0 */
  67               	/* stack size = 0 */
  68               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  69               		.loc 1 89 0
  70 0000 0C94 0000 		jmp matrix_init_kb
  71               	.LVL1:
  72               		.cfi_endproc
  73               	.LFE6:
  75               		.section	.text.matrix_scan_kb,"ax",@progbits
  76               		.weak	matrix_scan_kb
  78               	matrix_scan_kb:
  79               	.LFB9:
 103:quantum/matrix.c ****     matrix_scan_user();
  80               		.loc 1 103 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  86               		.loc 1 104 0
  87 0000 0C94 0000 		jmp matrix_scan_user
  88               	.LVL2:
  89               		.cfi_endproc
  90               	.LFE9:
  92               		.section	.text.matrix_scan_quantum,"ax",@progbits
  93               		.weak	matrix_scan_quantum
  95               	matrix_scan_quantum:
  96               	.LFB7:
  93:quantum/matrix.c ****     matrix_scan_kb();
  97               		.loc 1 93 0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 103               		.loc 1 94 0
 104 0000 0C94 0000 		jmp matrix_scan_kb
 105               	.LVL3:
 106               		.cfi_endproc
 107               	.LFE7:
 109               		.section	.text.matrix_rows,"ax",@progbits
 110               	.global	matrix_rows
 112               	matrix_rows:
 113               	.LFB27:
 114               		.cfi_startproc
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
 119 0000 86E0      		ldi r24,lo8(6)
 120 0002 0895      		ret
 121               		.cfi_endproc
 122               	.LFE27:
 124               		.section	.text.matrix_cols,"ax",@progbits
 125               	.global	matrix_cols
 127               	matrix_cols:
 128               	.LFB13:
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 118:quantum/matrix.c **** }
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 129               		.loc 1 121 0
 130               		.cfi_startproc
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 0 */
 134               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 123:quantum/matrix.c **** }
 135               		.loc 1 123 0
 136 0000 86E0      		ldi r24,lo8(6)
 137 0002 0895      		ret
 138               		.cfi_endproc
 139               	.LFE13:
 141               		.section	.text.matrix_init,"ax",@progbits
 142               	.global	matrix_init
 144               	matrix_init:
 145               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #else
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 146               		.loc 1 149 0
 147               		.cfi_startproc
 148 0000 CF93      		push r28
 149               	.LCFI0:
 150               		.cfi_def_cfa_offset 3
 151               		.cfi_offset 28, -2
 152 0002 DF93      		push r29
 153               	.LCFI1:
 154               		.cfi_def_cfa_offset 4
 155               		.cfi_offset 29, -3
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 2 */
 159               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 160               		.loc 1 153 0
 161 0004 85B7      		in r24,0x35
 162 0006 8068      		ori r24,lo8(-128)
 163 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 164               		.loc 1 154 0
 165 000a 85B7      		in r24,0x35
 166 000c 8068      		ori r24,lo8(-128)
 167 000e 85BF      		out 0x35,r24
 168               	.LVL4:
 169 0010 A0E0      		ldi r26,lo8(row_pins)
 170 0012 B0E0      		ldi r27,hi8(row_pins)
 171 0014 40E0      		ldi r20,lo8(row_pins+6)
 172 0016 50E0      		ldi r21,hi8(row_pins+6)
 173               	.LBB19:
 174               	.LBB20:
 175               	.LBB21:
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #else // ROW2COL
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_raw[i] = 0;
 170:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 171:quantum/matrix.c ****     }
 172:quantum/matrix.c **** 
 173:quantum/matrix.c ****     matrix_init_quantum();
 174:quantum/matrix.c **** }
 175:quantum/matrix.c **** 
 176:quantum/matrix.c **** uint8_t matrix_scan(void)
 177:quantum/matrix.c **** {
 178:quantum/matrix.c **** 
 179:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Set row, read cols
 182:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 183:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 184:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 185:quantum/matrix.c **** 
 186:quantum/matrix.c ****             if (matrix_changed) {
 187:quantum/matrix.c ****                 debouncing = true;
 188:quantum/matrix.c ****                 debouncing_time = timer_read();
 189:quantum/matrix.c ****             }
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** #       else
 192:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 193:quantum/matrix.c **** #       endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     }
 196:quantum/matrix.c **** 
 197:quantum/matrix.c **** #else // ROW2COL
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // Set col, read rows
 200:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 201:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 202:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 203:quantum/matrix.c ****             if (matrix_changed) {
 204:quantum/matrix.c ****                 debouncing = true;
 205:quantum/matrix.c ****                 debouncing_time = timer_read();
 206:quantum/matrix.c ****             }
 207:quantum/matrix.c **** #       else
 208:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 209:quantum/matrix.c **** #       endif
 210:quantum/matrix.c **** 
 211:quantum/matrix.c ****     }
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #endif
 214:quantum/matrix.c **** 
 215:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 216:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 217:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 218:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 219:quantum/matrix.c ****             }
 220:quantum/matrix.c ****             debouncing = false;
 221:quantum/matrix.c ****         }
 222:quantum/matrix.c **** #   endif
 223:quantum/matrix.c **** 
 224:quantum/matrix.c ****     matrix_scan_quantum();
 225:quantum/matrix.c ****     return 1;
 226:quantum/matrix.c **** }
 227:quantum/matrix.c **** 
 228:quantum/matrix.c **** bool matrix_is_modified(void)
 229:quantum/matrix.c **** {
 230:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 231:quantum/matrix.c ****     if (debouncing) return false;
 232:quantum/matrix.c **** #endif
 233:quantum/matrix.c ****     return true;
 234:quantum/matrix.c **** }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c **** inline
 237:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 238:quantum/matrix.c **** {
 239:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** inline
 243:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 244:quantum/matrix.c **** {
 245:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 246:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 247:quantum/matrix.c **** #ifdef MATRIX_MASKED
 248:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 249:quantum/matrix.c **** #else
 250:quantum/matrix.c ****     return matrix[row];
 251:quantum/matrix.c **** #endif
 252:quantum/matrix.c **** }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c **** void matrix_print(void)
 255:quantum/matrix.c **** {
 256:quantum/matrix.c ****     print_matrix_header();
 257:quantum/matrix.c **** 
 258:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 259:quantum/matrix.c ****         phex(row); print(": ");
 260:quantum/matrix.c ****         print_matrix_row(row);
 261:quantum/matrix.c ****         print("\n");
 262:quantum/matrix.c ****     }
 263:quantum/matrix.c **** }
 264:quantum/matrix.c **** 
 265:quantum/matrix.c **** uint8_t matrix_key_count(void)
 266:quantum/matrix.c **** {
 267:quantum/matrix.c ****     uint8_t count = 0;
 268:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 269:quantum/matrix.c ****         count += matrix_bitpop(i);
 270:quantum/matrix.c ****     }
 271:quantum/matrix.c ****     return count;
 272:quantum/matrix.c **** }
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** 
 276:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 277:quantum/matrix.c **** 
 278:quantum/matrix.c **** static void init_cols(void)
 279:quantum/matrix.c **** {
 280:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 281:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 283:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 284:quantum/matrix.c ****     }
 285:quantum/matrix.c **** }
 286:quantum/matrix.c **** 
 287:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 288:quantum/matrix.c **** {
 289:quantum/matrix.c ****     // Store last value of row prior to reading
 290:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 291:quantum/matrix.c **** 
 292:quantum/matrix.c ****     // Clear data in matrix row
 293:quantum/matrix.c ****     current_matrix[current_row] = 0;
 294:quantum/matrix.c **** 
 295:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 296:quantum/matrix.c ****     select_row(current_row);
 297:quantum/matrix.c ****     wait_us(30);
 298:quantum/matrix.c **** 
 299:quantum/matrix.c ****     // For each col...
 300:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 301:quantum/matrix.c **** 
 302:quantum/matrix.c ****         // Select the col pin to read (active low)
 303:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 304:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 305:quantum/matrix.c **** 
 306:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 307:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 308:quantum/matrix.c ****     }
 309:quantum/matrix.c **** 
 310:quantum/matrix.c ****     // Unselect row
 311:quantum/matrix.c ****     unselect_row(current_row);
 312:quantum/matrix.c **** 
 313:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 314:quantum/matrix.c **** }
 315:quantum/matrix.c **** 
 316:quantum/matrix.c **** static void select_row(uint8_t row)
 317:quantum/matrix.c **** {
 318:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 320:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 321:quantum/matrix.c **** }
 322:quantum/matrix.c **** 
 323:quantum/matrix.c **** static void unselect_row(uint8_t row)
 324:quantum/matrix.c **** {
 325:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 327:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 328:quantum/matrix.c **** }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c **** static void unselect_rows(void)
 331:quantum/matrix.c **** {
 332:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 333:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 176               		.loc 1 334 0
 177 0018 61E0      		ldi r22,lo8(1)
 178 001a 70E0      		ldi r23,0
 179               	.LVL5:
 180               	.L10:
 333:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 181               		.loc 1 333 0
 182 001c 8D91      		ld r24,X+
 183               	.LVL6:
 184               		.loc 1 334 0
 185 001e E82F      		mov r30,r24
 186 0020 E295      		swap r30
 187 0022 EF70      		andi r30,lo8(15)
 188 0024 F0E0      		ldi r31,0
 189 0026 21A1      		ldd r18,Z+33
 190 0028 8F70      		andi r24,lo8(15)
 191               	.LVL7:
 192 002a EB01      		movw r28,r22
 193 002c 00C0      		rjmp 2f
 194               		1:
 195 002e CC0F      		lsl r28
 196 0030 DD1F      		rol r29
 197               		2:
 198 0032 8A95      		dec r24
 199 0034 02F4      		brpl 1b
 200 0036 CE01      		movw r24,r28
 201 0038 9C2F      		mov r25,r28
 202 003a 9095      		com r25
 203 003c 9223      		and r25,r18
 204 003e 91A3      		std Z+33,r25
 205               	.LVL8:
 335:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 206               		.loc 1 335 0
 207 0040 92A1      		ldd r25,Z+34
 208 0042 892B      		or r24,r25
 209 0044 82A3      		std Z+34,r24
 210               	.LVL9:
 211               	.LBE21:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 212               		.loc 1 332 0
 213 0046 4A17      		cp r20,r26
 214 0048 5B07      		cpc r21,r27
 215 004a 01F4      		brne .L10
 216 004c A0E0      		ldi r26,lo8(col_pins)
 217 004e B0E0      		ldi r27,hi8(col_pins)
 218               	.LVL10:
 219 0050 40E0      		ldi r20,lo8(col_pins+6)
 220 0052 50E0      		ldi r21,hi8(col_pins+6)
 221               	.LBE20:
 222               	.LBE19:
 223               	.LBB22:
 224               	.LBB23:
 225               	.LBB24:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 226               		.loc 1 282 0
 227 0054 61E0      		ldi r22,lo8(1)
 228 0056 70E0      		ldi r23,0
 229               	.L11:
 230               	.LVL11:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 231               		.loc 1 281 0
 232 0058 8D91      		ld r24,X+
 233               	.LVL12:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 234               		.loc 1 282 0
 235 005a E82F      		mov r30,r24
 236 005c E295      		swap r30
 237 005e EF70      		andi r30,lo8(15)
 238 0060 F0E0      		ldi r31,0
 239 0062 21A1      		ldd r18,Z+33
 240 0064 8F70      		andi r24,lo8(15)
 241               	.LVL13:
 242 0066 EB01      		movw r28,r22
 243 0068 00C0      		rjmp 2f
 244               		1:
 245 006a CC0F      		lsl r28
 246 006c DD1F      		rol r29
 247               		2:
 248 006e 8A95      		dec r24
 249 0070 02F4      		brpl 1b
 250 0072 CE01      		movw r24,r28
 251 0074 9C2F      		mov r25,r28
 252 0076 9095      		com r25
 253 0078 9223      		and r25,r18
 254 007a 91A3      		std Z+33,r25
 255               	.LVL14:
 283:quantum/matrix.c ****     }
 256               		.loc 1 283 0
 257 007c 92A1      		ldd r25,Z+34
 258 007e 892B      		or r24,r25
 259 0080 82A3      		std Z+34,r24
 260               	.LVL15:
 261               	.LBE24:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 262               		.loc 1 280 0
 263 0082 4A17      		cp r20,r26
 264 0084 5B07      		cpc r21,r27
 265 0086 01F4      		brne .L11
 266 0088 E0E0      		ldi r30,lo8(matrix)
 267 008a F0E0      		ldi r31,hi8(matrix)
 268 008c A0E0      		ldi r26,lo8(matrix_debouncing)
 269 008e B0E0      		ldi r27,hi8(matrix_debouncing)
 270               	.LVL16:
 271 0090 80E0      		ldi r24,lo8(matrix+6)
 272 0092 90E0      		ldi r25,hi8(matrix+6)
 273               	.L12:
 274               	.LVL17:
 275               	.LBE23:
 276               	.LBE22:
 277               	.LBB25:
 168:quantum/matrix.c ****         matrix_raw[i] = 0;
 278               		.loc 1 168 0 discriminator 3
 279 0094 1192      		st Z+,__zero_reg__
 280               	.LVL18:
 170:quantum/matrix.c ****     }
 281               		.loc 1 170 0 discriminator 3
 282 0096 1D92      		st X+,__zero_reg__
 283               	.LVL19:
 167:quantum/matrix.c ****         matrix[i] = 0;
 284               		.loc 1 167 0 discriminator 3
 285 0098 8E17      		cp r24,r30
 286 009a 9F07      		cpc r25,r31
 287 009c 01F4      		brne .L12
 288               	/* epilogue start */
 289               	.LBE25:
 174:quantum/matrix.c **** 
 290               		.loc 1 174 0
 291 009e DF91      		pop r29
 292 00a0 CF91      		pop r28
 173:quantum/matrix.c **** }
 293               		.loc 1 173 0
 294 00a2 0C94 0000 		jmp matrix_init_quantum
 295               	.LVL20:
 296               		.cfi_endproc
 297               	.LFE14:
 299               		.section	.text.matrix_scan,"ax",@progbits
 300               	.global	matrix_scan
 302               	matrix_scan:
 303               	.LFB15:
 177:quantum/matrix.c **** 
 304               		.loc 1 177 0
 305               		.cfi_startproc
 306 0000 4F92      		push r4
 307               	.LCFI2:
 308               		.cfi_def_cfa_offset 3
 309               		.cfi_offset 4, -2
 310 0002 5F92      		push r5
 311               	.LCFI3:
 312               		.cfi_def_cfa_offset 4
 313               		.cfi_offset 5, -3
 314 0004 6F92      		push r6
 315               	.LCFI4:
 316               		.cfi_def_cfa_offset 5
 317               		.cfi_offset 6, -4
 318 0006 7F92      		push r7
 319               	.LCFI5:
 320               		.cfi_def_cfa_offset 6
 321               		.cfi_offset 7, -5
 322 0008 8F92      		push r8
 323               	.LCFI6:
 324               		.cfi_def_cfa_offset 7
 325               		.cfi_offset 8, -6
 326 000a 9F92      		push r9
 327               	.LCFI7:
 328               		.cfi_def_cfa_offset 8
 329               		.cfi_offset 9, -7
 330 000c AF92      		push r10
 331               	.LCFI8:
 332               		.cfi_def_cfa_offset 9
 333               		.cfi_offset 10, -8
 334 000e BF92      		push r11
 335               	.LCFI9:
 336               		.cfi_def_cfa_offset 10
 337               		.cfi_offset 11, -9
 338 0010 CF92      		push r12
 339               	.LCFI10:
 340               		.cfi_def_cfa_offset 11
 341               		.cfi_offset 12, -10
 342 0012 DF92      		push r13
 343               	.LCFI11:
 344               		.cfi_def_cfa_offset 12
 345               		.cfi_offset 13, -11
 346 0014 EF92      		push r14
 347               	.LCFI12:
 348               		.cfi_def_cfa_offset 13
 349               		.cfi_offset 14, -12
 350 0016 FF92      		push r15
 351               	.LCFI13:
 352               		.cfi_def_cfa_offset 14
 353               		.cfi_offset 15, -13
 354 0018 0F93      		push r16
 355               	.LCFI14:
 356               		.cfi_def_cfa_offset 15
 357               		.cfi_offset 16, -14
 358 001a 1F93      		push r17
 359               	.LCFI15:
 360               		.cfi_def_cfa_offset 16
 361               		.cfi_offset 17, -15
 362 001c CF93      		push r28
 363               	.LCFI16:
 364               		.cfi_def_cfa_offset 17
 365               		.cfi_offset 28, -16
 366 001e DF93      		push r29
 367               	.LCFI17:
 368               		.cfi_def_cfa_offset 18
 369               		.cfi_offset 29, -17
 370               	/* prologue: function */
 371               	/* frame size = 0 */
 372               	/* stack size = 16 */
 373               	.L__stack_usage = 16
 374               	.LVL21:
 375 0020 20E0      		ldi r18,lo8(row_pins)
 376 0022 C22E      		mov r12,r18
 377 0024 20E0      		ldi r18,hi8(row_pins)
 378 0026 D22E      		mov r13,r18
 379 0028 00E0      		ldi r16,lo8(matrix_debouncing)
 380 002a 10E0      		ldi r17,hi8(matrix_debouncing)
 177:quantum/matrix.c **** 
 381               		.loc 1 177 0
 382 002c E801      		movw r28,r16
 383               	.LBB39:
 384               	.LBB40:
 385               	.LBB41:
 386               	.LBB42:
 387               	.LBB43:
 388               	.LBB44:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 389               		.loc 1 319 0
 390 002e EE24      		clr r14
 391 0030 E394      		inc r14
 392 0032 F12C      		mov r15,__zero_reg__
 393               	.LBE44:
 394               	.LBE43:
 395               	.LBE42:
 396               	.LBE41:
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 397               		.loc 1 187 0
 398 0034 BB24      		clr r11
 399 0036 B394      		inc r11
 400               	.LVL22:
 401               	.L21:
 402 0038 BE01      		movw r22,r28
 403               	.LBB54:
 404               	.LBB53:
 290:quantum/matrix.c **** 
 405               		.loc 1 290 0
 406 003a 9880      		ld r9,Y
 407               	.LVL23:
 293:quantum/matrix.c **** 
 408               		.loc 1 293 0
 409 003c 1882      		st Y,__zero_reg__
 410               	.LVL24:
 411               	.LBB46:
 412               	.LBB45:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 413               		.loc 1 318 0
 414 003e D601      		movw r26,r12
 415 0040 8D91      		ld r24,X+
 416 0042 6D01      		movw r12,r26
 417               	.LVL25:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 418               		.loc 1 319 0
 419 0044 E82F      		mov r30,r24
 420 0046 E295      		swap r30
 421 0048 EF70      		andi r30,lo8(15)
 422 004a F0E0      		ldi r31,0
 423 004c 21A1      		ldd r18,Z+33
 424 004e 8F70      		andi r24,lo8(15)
 425               	.LVL26:
 426 0050 A701      		movw r20,r14
 427 0052 00C0      		rjmp 2f
 428               		1:
 429 0054 440F      		lsl r20
 430 0056 551F      		rol r21
 431               		2:
 432 0058 8A95      		dec r24
 433 005a 02F4      		brpl 1b
 434 005c CA01      		movw r24,r20
 435 005e 242B      		or r18,r20
 436 0060 21A3      		std Z+33,r18
 437               	.LVL27:
 320:quantum/matrix.c **** }
 438               		.loc 1 320 0
 439 0062 22A1      		ldd r18,Z+34
 440 0064 A42E      		mov r10,r20
 441 0066 A094      		com r10
 442 0068 2A21      		and r18,r10
 443 006a 22A3      		std Z+34,r18
 444               	.LVL28:
 445               	.LBE45:
 446               	.LBE46:
 447               	.LBB47:
 448               	.LBB48:
 449               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 450               		.loc 2 276 0
 451 006c 50EA      		ldi r21,lo8(-96)
 452 006e 5A95      	1:	dec r21
 453 0070 01F4      		brne 1b
 454               	.LVL29:
 455 0072 90E0      		ldi r25,lo8(col_pins)
 456 0074 492E      		mov r4,r25
 457 0076 90E0      		ldi r25,hi8(col_pins)
 458 0078 592E      		mov r5,r25
 459 007a 20E0      		ldi r18,0
 460 007c 30E0      		ldi r19,0
 461               	.LVL30:
 462               	.L19:
 463               	.LBE48:
 464               	.LBE47:
 465               	.LBB49:
 466               	.LBB50:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 467               		.loc 1 303 0
 468 007e D201      		movw r26,r4
 469 0080 8D90      		ld r8,X+
 470 0082 2D01      		movw r4,r26
 471               	.LVL31:
 304:quantum/matrix.c **** 
 472               		.loc 1 304 0
 473 0084 482D      		mov r20,r8
 474 0086 4295      		swap r20
 475 0088 4F70      		andi r20,lo8(15)
 476 008a 50E0      		ldi r21,0
 477 008c DA01      		movw r26,r20
 478 008e 9096      		adiw r26,32
 479 0090 6C90      		ld r6,X
 480               	.LVL32:
 307:quantum/matrix.c ****     }
 481               		.loc 1 307 0
 482 0092 7880      		ld r7,Y
 483 0094 582D      		mov r21,r8
 484 0096 5F70      		andi r21,lo8(15)
 485               	.LVL33:
 486 0098 D701      		movw r26,r14
 487 009a 00C0      		rjmp 2f
 488               		1:
 489 009c AA0F      		lsl r26
 490 009e BB1F      		rol r27
 491               		2:
 492 00a0 5A95      		dec r21
 493 00a2 02F4      		brpl 1b
 494 00a4 AD01      		movw r20,r26
 495 00a6 562D      		mov r21,r6
 496               	.LVL34:
 497 00a8 5423      		and r21,r20
 498 00aa 01F4      		brne .L26
 499 00ac 5E2D      		mov r21,r14
 500 00ae 022E      		mov r0,r18
 501 00b0 00C0      		rjmp 2f
 502               		1:
 503 00b2 550F      		lsl r21
 504               		2:
 505 00b4 0A94      		dec r0
 506 00b6 02F4      		brpl 1b
 507 00b8 452F      		mov r20,r21
 508 00ba 00C0      		rjmp .L18
 509               	.L26:
 510 00bc 40E0      		ldi r20,0
 511               	.L18:
 512 00be 4729      		or r20,r7
 513 00c0 4883      		st Y,r20
 514               	.LVL35:
 515 00c2 2F5F      		subi r18,-1
 516 00c4 3F4F      		sbci r19,-1
 517               	.LVL36:
 518               	.LBE50:
 300:quantum/matrix.c **** 
 519               		.loc 1 300 0
 520 00c6 2630      		cpi r18,6
 521 00c8 3105      		cpc r19,__zero_reg__
 522 00ca 01F4      		brne .L19
 523               	.LVL37:
 524               	.LBE49:
 525               	.LBB51:
 526               	.LBB52:
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 527               		.loc 1 326 0
 528 00cc 91A1      		ldd r25,Z+33
 529 00ce A922      		and r10,r25
 530 00d0 A1A2      		std Z+33,r10
 327:quantum/matrix.c **** }
 531               		.loc 1 327 0
 532 00d2 92A1      		ldd r25,Z+34
 533 00d4 892B      		or r24,r25
 534 00d6 82A3      		std Z+34,r24
 535               	.LVL38:
 536 00d8 2196      		adiw r28,1
 537               	.LVL39:
 538               	.LBE52:
 539               	.LBE51:
 540               	.LBE53:
 541               	.LBE54:
 186:quantum/matrix.c ****                 debouncing = true;
 542               		.loc 1 186 0
 543 00da FB01      		movw r30,r22
 544 00dc 8081      		ld r24,Z
 545 00de 9816      		cp r9,r24
 546 00e0 01F0      		breq .L20
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 547               		.loc 1 187 0
 548 00e2 B092 0000 		sts debouncing,r11
 188:quantum/matrix.c ****             }
 549               		.loc 1 188 0
 550 00e6 0E94 0000 		call timer_read
 551               	.LVL40:
 552 00ea 9093 0000 		sts debouncing_time+1,r25
 553 00ee 8093 0000 		sts debouncing_time,r24
 554               	.L20:
 555               	.LVL41:
 556               	.LBE40:
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 557               		.loc 1 182 0 discriminator 2
 558 00f2 F0E0      		ldi r31,hi8(matrix_debouncing+6)
 559 00f4 C030      		cpi r28,lo8(matrix_debouncing+6)
 560 00f6 DF07      		cpc r29,r31
 561 00f8 01F0      		breq .+2
 562 00fa 00C0      		rjmp .L21
 563               	.LBE39:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 564               		.loc 1 216 0
 565 00fc 8091 0000 		lds r24,debouncing
 566 0100 8823      		tst r24
 567 0102 01F0      		breq .L23
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 568               		.loc 1 216 0 is_stmt 0 discriminator 1
 569 0104 8091 0000 		lds r24,debouncing_time
 570 0108 9091 0000 		lds r25,debouncing_time+1
 571 010c 0E94 0000 		call timer_elapsed
 572               	.LVL42:
 573 0110 0697      		sbiw r24,6
 574 0112 00F0      		brlo .L23
 575 0114 E0E0      		ldi r30,lo8(matrix)
 576 0116 F0E0      		ldi r31,hi8(matrix)
 577               	.L25:
 578               	.LVL43:
 579               	.LBB55:
 218:quantum/matrix.c ****             }
 580               		.loc 1 218 0 is_stmt 1 discriminator 3
 581 0118 D801      		movw r26,r16
 582 011a 8D91      		ld r24,X+
 583 011c 8D01      		movw r16,r26
 584               	.LVL44:
 585 011e 8193      		st Z+,r24
 586               	.LVL45:
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 587               		.loc 1 217 0 discriminator 3
 588 0120 B0E0      		ldi r27,hi8(matrix_debouncing+6)
 589 0122 0030      		cpi r16,lo8(matrix_debouncing+6)
 590 0124 1B07      		cpc r17,r27
 591 0126 01F4      		brne .L25
 592               	.LBE55:
 220:quantum/matrix.c ****         }
 593               		.loc 1 220 0
 594 0128 1092 0000 		sts debouncing,__zero_reg__
 595               	.LVL46:
 596               	.L23:
 224:quantum/matrix.c ****     return 1;
 597               		.loc 1 224 0
 598 012c 0E94 0000 		call matrix_scan_quantum
 599               	.LVL47:
 226:quantum/matrix.c **** 
 600               		.loc 1 226 0
 601 0130 81E0      		ldi r24,lo8(1)
 602               	/* epilogue start */
 603 0132 DF91      		pop r29
 604 0134 CF91      		pop r28
 605               	.LVL48:
 606 0136 1F91      		pop r17
 607 0138 0F91      		pop r16
 608 013a FF90      		pop r15
 609 013c EF90      		pop r14
 610 013e DF90      		pop r13
 611 0140 CF90      		pop r12
 612 0142 BF90      		pop r11
 613 0144 AF90      		pop r10
 614 0146 9F90      		pop r9
 615 0148 8F90      		pop r8
 616               	.LVL49:
 617 014a 7F90      		pop r7
 618 014c 6F90      		pop r6
 619 014e 5F90      		pop r5
 620 0150 4F90      		pop r4
 621 0152 0895      		ret
 622               		.cfi_endproc
 623               	.LFE15:
 625               		.section	.text.matrix_is_modified,"ax",@progbits
 626               	.global	matrix_is_modified
 628               	matrix_is_modified:
 629               	.LFB16:
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 630               		.loc 1 229 0
 631               		.cfi_startproc
 632               	/* prologue: function */
 633               	/* frame size = 0 */
 634               	/* stack size = 0 */
 635               	.L__stack_usage = 0
 636 0000 9091 0000 		lds r25,debouncing
 234:quantum/matrix.c **** 
 637               		.loc 1 234 0
 638 0004 81E0      		ldi r24,lo8(1)
 639 0006 8927      		eor r24,r25
 640 0008 0895      		ret
 641               		.cfi_endproc
 642               	.LFE16:
 644               		.section	.text.matrix_is_on,"ax",@progbits
 645               	.global	matrix_is_on
 647               	matrix_is_on:
 648               	.LFB17:
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 649               		.loc 1 238 0
 650               		.cfi_startproc
 651               	.LVL50:
 652               	/* prologue: function */
 653               	/* frame size = 0 */
 654               	/* stack size = 0 */
 655               	.L__stack_usage = 0
 239:quantum/matrix.c **** }
 656               		.loc 1 239 0
 657 0000 E82F      		mov r30,r24
 658 0002 F0E0      		ldi r31,0
 659 0004 E050      		subi r30,lo8(-(matrix))
 660 0006 F040      		sbci r31,hi8(-(matrix))
 661 0008 8081      		ld r24,Z
 662               	.LVL51:
 663 000a 282F      		mov r18,r24
 664 000c 30E0      		ldi r19,0
 665 000e 81E0      		ldi r24,lo8(1)
 666 0010 90E0      		ldi r25,0
 667 0012 6230      		cpi r22,lo8(2)
 668 0014 00F4      		brsh .L32
 669 0016 80E0      		ldi r24,0
 670 0018 90E0      		ldi r25,0
 671               	.L32:
 672 001a 8223      		and r24,r18
 673 001c 9323      		and r25,r19
 240:quantum/matrix.c **** 
 674               		.loc 1 240 0
 675 001e 8170      		andi r24,lo8(1)
 676 0020 0895      		ret
 677               		.cfi_endproc
 678               	.LFE17:
 680               		.section	.text.matrix_get_row,"ax",@progbits
 681               	.global	matrix_get_row
 683               	matrix_get_row:
 684               	.LFB18:
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 685               		.loc 1 244 0
 686               		.cfi_startproc
 687               	.LVL52:
 688               	/* prologue: function */
 689               	/* frame size = 0 */
 690               	/* stack size = 0 */
 691               	.L__stack_usage = 0
 250:quantum/matrix.c **** #endif
 692               		.loc 1 250 0
 693 0000 E82F      		mov r30,r24
 694 0002 F0E0      		ldi r31,0
 695 0004 E050      		subi r30,lo8(-(matrix))
 696 0006 F040      		sbci r31,hi8(-(matrix))
 252:quantum/matrix.c **** 
 697               		.loc 1 252 0
 698 0008 8081      		ld r24,Z
 699               	.LVL53:
 700 000a 0895      		ret
 701               		.cfi_endproc
 702               	.LFE18:
 704               		.section	.text.matrix_print,"ax",@progbits
 705               	.global	matrix_print
 707               	matrix_print:
 708               	.LFB19:
 255:quantum/matrix.c ****     print_matrix_header();
 709               		.loc 1 255 0
 710               		.cfi_startproc
 711               	/* prologue: function */
 712               	/* frame size = 0 */
 713               	/* stack size = 0 */
 714               	.L__stack_usage = 0
 715               	.LVL54:
 716 0000 0895      		ret
 717               		.cfi_endproc
 718               	.LFE19:
 720               		.section	.text.matrix_key_count,"ax",@progbits
 721               	.global	matrix_key_count
 723               	matrix_key_count:
 724               	.LFB20:
 266:quantum/matrix.c ****     uint8_t count = 0;
 725               		.loc 1 266 0
 726               		.cfi_startproc
 266:quantum/matrix.c ****     uint8_t count = 0;
 727               		.loc 1 266 0
 728 0000 0F93      		push r16
 729               	.LCFI18:
 730               		.cfi_def_cfa_offset 3
 731               		.cfi_offset 16, -2
 732 0002 1F93      		push r17
 733               	.LCFI19:
 734               		.cfi_def_cfa_offset 4
 735               		.cfi_offset 17, -3
 736 0004 CF93      		push r28
 737               	.LCFI20:
 738               		.cfi_def_cfa_offset 5
 739               		.cfi_offset 28, -4
 740               	/* prologue: function */
 741               	/* frame size = 0 */
 742               	/* stack size = 3 */
 743               	.L__stack_usage = 3
 744               	.LVL55:
 745 0006 00E0      		ldi r16,lo8(matrix)
 746 0008 10E0      		ldi r17,hi8(matrix)
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 747               		.loc 1 267 0
 748 000a C0E0      		ldi r28,0
 749               	.LVL56:
 750               	.L36:
 751               	.LBB56:
 269:quantum/matrix.c ****     }
 752               		.loc 1 269 0 discriminator 3
 753 000c F801      		movw r30,r16
 754 000e 8191      		ld r24,Z+
 755 0010 8F01      		movw r16,r30
 756               	.LVL57:
 757 0012 0E94 0000 		call bitpop
 758               	.LVL58:
 759 0016 C80F      		add r28,r24
 760               	.LVL59:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 761               		.loc 1 268 0 discriminator 3
 762 0018 F0E0      		ldi r31,hi8(matrix+6)
 763 001a 0030      		cpi r16,lo8(matrix+6)
 764 001c 1F07      		cpc r17,r31
 765 001e 01F4      		brne .L36
 766               	.LBE56:
 272:quantum/matrix.c **** 
 767               		.loc 1 272 0
 768 0020 8C2F      		mov r24,r28
 769               	/* epilogue start */
 770 0022 CF91      		pop r28
 771               	.LVL60:
 772 0024 1F91      		pop r17
 773 0026 0F91      		pop r16
 774               	.LVL61:
 775 0028 0895      		ret
 776               		.cfi_endproc
 777               	.LFE20:
 779               		.section	.bss.matrix_debouncing,"aw",@nobits
 782               	matrix_debouncing:
 783 0000 0000 0000 		.zero	6
 783      0000 
 784               		.section	.bss.matrix,"aw",@nobits
 787               	matrix:
 788 0000 0000 0000 		.zero	6
 788      0000 
 789               		.section	.rodata.col_pins,"a",@progbits
 792               	col_pins:
 793 0000 92        		.byte	-110
 794 0001 34        		.byte	52
 795 0002 94        		.byte	-108
 796 0003 F7        		.byte	-9
 797 0004 F5        		.byte	-11
 798 0005 31        		.byte	49
 799               		.section	.rodata.row_pins,"a",@progbits
 802               	row_pins:
 803 0000 93        		.byte	-109
 804 0001 35        		.byte	53
 805 0002 91        		.byte	-111
 806 0003 C6        		.byte	-58
 807 0004 F4        		.byte	-12
 808 0005 33        		.byte	51
 809               		.section	.bss.debouncing,"aw",@nobits
 812               	debouncing:
 813 0000 00        		.zero	1
 814               		.section	.bss.debouncing_time,"aw",@nobits
 817               	debouncing_time:
 818 0000 0000      		.zero	2
 819               		.text
 820               	.Letext0:
 821               		.file 3 "/usr/lib/avr/include/stdint.h"
 822               		.file 4 "./tmk_core/common/matrix.h"
 823               		.file 5 "./tmk_core/common/timer.h"
 824               		.file 6 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccavRmno.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccavRmno.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccavRmno.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccavRmno.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccavRmno.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccavRmno.s:13     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccavRmno.s:13     .text.matrix_scan_user:0000000000000000 matrix_scan_user.localalias.0
     /tmp/ccavRmno.s:30     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccavRmno.s:44     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccavRmno.s:61     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccavRmno.s:78     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccavRmno.s:95     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccavRmno.s:112    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccavRmno.s:127    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccavRmno.s:144    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccavRmno.s:802    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccavRmno.s:792    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccavRmno.s:787    .bss.matrix:0000000000000000 matrix
     /tmp/ccavRmno.s:782    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccavRmno.s:302    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccavRmno.s:812    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccavRmno.s:817    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccavRmno.s:628    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccavRmno.s:647    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccavRmno.s:683    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccavRmno.s:707    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccavRmno.s:723    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop
__do_copy_data
__do_clear_bss
